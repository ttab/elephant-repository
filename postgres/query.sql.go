// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireTXLock = `-- name: AcquireTXLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireTXLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, acquireTXLock, id)
	return err
}

const activateSchema = `-- name: ActivateSchema :exec
INSERT INTO active_schemas(name, version)
VALUES ($1, $2)
       ON CONFLICT(name) DO UPDATE SET
          version = $2
`

type ActivateSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) ActivateSchema(ctx context.Context, arg ActivateSchemaParams) error {
	_, err := q.db.Exec(ctx, activateSchema, arg.Name, arg.Version)
	return err
}

const bulkCheckPermissions = `-- name: BulkCheckPermissions :many
SELECT d.uuid
FROM document AS d
     INNER JOIN acl
          ON (acl.uuid = d.uuid OR acl.uuid = d.main_doc)
          AND acl.uri = ANY($1::text[])
          AND $2::text[] && permissions
WHERE d.uuid = ANY($3::uuid[])
`

type BulkCheckPermissionsParams struct {
	URI         []string
	Permissions []string
	Uuids       []uuid.UUID
}

func (q *Queries) BulkCheckPermissions(ctx context.Context, arg BulkCheckPermissionsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, bulkCheckPermissions, arg.URI, arg.Permissions, arg.Uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var uuid uuid.UUID
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetDocumentData = `-- name: BulkGetDocumentData :many
WITH refs AS (
     SELECT unnest($1::uuid[]) AS uuid,
            unnest($2::bigint[]) AS version
)
SELECT v.uuid, v.version, v.document_data
FROM refs AS r
     INNER JOIN document as d ON d.uuid = r.uuid
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid AND (
                  (r.version = 0 AND v.version = d.current_version)
                  OR v.version = r.version
           )
`

type BulkGetDocumentDataParams struct {
	Uuids    []uuid.UUID
	Versions []int64
}

type BulkGetDocumentDataRow struct {
	UUID         uuid.UUID
	Version      int64
	DocumentData []byte
}

func (q *Queries) BulkGetDocumentData(ctx context.Context, arg BulkGetDocumentDataParams) ([]BulkGetDocumentDataRow, error) {
	rows, err := q.db.Query(ctx, bulkGetDocumentData, arg.Uuids, arg.Versions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkGetDocumentDataRow
	for rows.Next() {
		var i BulkGetDocumentDataRow
		if err := rows.Scan(&i.UUID, &i.Version, &i.DocumentData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkForPendingPurge = `-- name: CheckForPendingPurge :one
SELECT EXISTS (
       SELECT 1 FROM purge_request
       WHERE delete_record_id = $1
       AND finished IS NULL
)
`

func (q *Queries) CheckForPendingPurge(ctx context.Context, deleteRecordID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkForPendingPurge, deleteRecordID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMetaDocumentType = `-- name: CheckMetaDocumentType :one
SELECT coalesce(meta_type, ''), NOT d.main_doc IS NULL as is_meta_doc
FROM document AS d
     LEFT JOIN meta_type_use AS m ON m.main_type = d.type
WHERE d.uuid = $1
`

type CheckMetaDocumentTypeRow struct {
	MetaType  string
	IsMetaDoc pgtype.Bool
}

func (q *Queries) CheckMetaDocumentType(ctx context.Context, argUuid uuid.UUID) (CheckMetaDocumentTypeRow, error) {
	row := q.db.QueryRow(ctx, checkMetaDocumentType, argUuid)
	var i CheckMetaDocumentTypeRow
	err := row.Scan(&i.MetaType, &i.IsMetaDoc)
	return i, err
}

const checkPermissions = `-- name: CheckPermissions :one
SELECT (acl.uri IS NOT NULL) = true AS has_access, d.system_state
FROM document AS d
     LEFT JOIN acl
          ON (acl.uuid = d.uuid OR acl.uuid = d.main_doc)
          AND acl.uri = ANY($1::text[])
          AND $2::text[] && permissions
WHERE d.uuid = $3
`

type CheckPermissionsParams struct {
	URI         []string
	Permissions []string
	UUID        uuid.UUID
}

type CheckPermissionsRow struct {
	HasAccess   bool
	SystemState pgtype.Text
}

func (q *Queries) CheckPermissions(ctx context.Context, arg CheckPermissionsParams) (CheckPermissionsRow, error) {
	row := q.db.QueryRow(ctx, checkPermissions, arg.URI, arg.Permissions, arg.UUID)
	var i CheckPermissionsRow
	err := row.Scan(&i.HasAccess, &i.SystemState)
	return i, err
}

const cleanUpAssignees = `-- name: CleanUpAssignees :exec
DELETE FROM planning_assignee
WHERE assignment = $1 AND version != $2
`

type CleanUpAssigneesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpAssignees(ctx context.Context, arg CleanUpAssigneesParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignees, arg.Assignment, arg.Version)
	return err
}

const cleanUpAssignments = `-- name: CleanUpAssignments :exec
DELETE FROM planning_assignment
WHERE planning_item = $1 AND version != $2
`

type CleanUpAssignmentsParams struct {
	PlanningItem uuid.UUID
	Version      int64
}

func (q *Queries) CleanUpAssignments(ctx context.Context, arg CleanUpAssignmentsParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignments, arg.PlanningItem, arg.Version)
	return err
}

const cleanUpDeliverables = `-- name: CleanUpDeliverables :exec
DELETE FROM planning_deliverable
WHERE assignment = $1 AND version != $2
`

type CleanUpDeliverablesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpDeliverables(ctx context.Context, arg CleanUpDeliverablesParams) error {
	_, err := q.db.Exec(ctx, cleanUpDeliverables, arg.Assignment, arg.Version)
	return err
}

const clearSystemState = `-- name: ClearSystemState :exec
UPDATE document SET system_state = NULL
WHERE uuid = $1 AND NOT system_state IS NULL
`

func (q *Queries) ClearSystemState(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearSystemState, argUuid)
	return err
}

const configureEventsink = `-- name: ConfigureEventsink :exec
INSERT INTO eventsink(name, configuration) VALUES($1, $2)
ON CONFLICT (name) DO UPDATE SET
   configuration = $2
`

type ConfigureEventsinkParams struct {
	Name   string
	Config []byte
}

func (q *Queries) ConfigureEventsink(ctx context.Context, arg ConfigureEventsinkParams) error {
	_, err := q.db.Exec(ctx, configureEventsink, arg.Name, arg.Config)
	return err
}

const createDocumentVersion = `-- name: CreateDocumentVersion :exec
INSERT INTO document_version(
       uuid, version,
       created, creator_uri, meta, document_data, archived, language
) VALUES (
       $1, $2,
       $3, $4, $5, $6, false, $7
)
`

type CreateDocumentVersionParams struct {
	UUID         uuid.UUID
	Version      int64
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Language     pgtype.Text
}

func (q *Queries) CreateDocumentVersion(ctx context.Context, arg CreateDocumentVersionParams) error {
	_, err := q.db.Exec(ctx, createDocumentVersion,
		arg.UUID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.DocumentData,
		arg.Language,
	)
	return err
}

const createStatusHead = `-- name: CreateStatusHead :exec
INSERT INTO status_heads(
       uuid, name, type, version, current_id,
       updated, updater_uri, language, system_state
) VALUES (
       $1, $2, $3::text, $4::bigint, $5::bigint,
       $6, $7, $8::text, $9
)
ON CONFLICT (uuid, name) DO UPDATE
   SET updated = $6,
       updater_uri = $7,
       current_id = $5::bigint,
       version = $4::bigint,
       language = $8::text
`

type CreateStatusHeadParams struct {
	UUID        uuid.UUID
	Name        string
	Type        string
	Version     int64
	ID          int64
	Created     pgtype.Timestamptz
	CreatorUri  string
	Language    string
	SystemState pgtype.Text
}

func (q *Queries) CreateStatusHead(ctx context.Context, arg CreateStatusHeadParams) error {
	_, err := q.db.Exec(ctx, createStatusHead,
		arg.UUID,
		arg.Name,
		arg.Type,
		arg.Version,
		arg.ID,
		arg.Created,
		arg.CreatorUri,
		arg.Language,
		arg.SystemState,
	)
	return err
}

const deactivateSchema = `-- name: DeactivateSchema :exec
DELETE FROM active_schemas
WHERE name = $1
`

func (q *Queries) DeactivateSchema(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deactivateSchema, name)
	return err
}

const deleteDocumentEntry = `-- name: DeleteDocumentEntry :exec
DELETE FROM document WHERE uuid = $1
`

func (q *Queries) DeleteDocumentEntry(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentEntry, argUuid)
	return err
}

const deleteDocumentLock = `-- name: DeleteDocumentLock :execrows
DELETE FROM document_lock
WHERE uuid = $1
  AND token = $2
`

type DeleteDocumentLockParams struct {
	UUID  uuid.UUID
	Token string
}

func (q *Queries) DeleteDocumentLock(ctx context.Context, arg DeleteDocumentLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteDocumentLock, arg.UUID, arg.Token)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredDocumentLock = `-- name: DeleteExpiredDocumentLock :exec
DELETE FROM document_lock
WHERE uuid = ANY($1::uuid[])
  AND expires < $2
`

type DeleteExpiredDocumentLockParams struct {
	Uuids  []uuid.UUID
	Cutoff pgtype.Timestamptz
}

func (q *Queries) DeleteExpiredDocumentLock(ctx context.Context, arg DeleteExpiredDocumentLockParams) error {
	_, err := q.db.Exec(ctx, deleteExpiredDocumentLock, arg.Uuids, arg.Cutoff)
	return err
}

const deleteMetricKind = `-- name: DeleteMetricKind :exec
DELETE FROM metric_kind
WHERE name = $1
`

func (q *Queries) DeleteMetricKind(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteMetricKind, name)
	return err
}

const deletePlanningItem = `-- name: DeletePlanningItem :exec
DELETE FROM planning_item WHERE uuid = $1
`

func (q *Queries) DeletePlanningItem(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlanningItem, argUuid)
	return err
}

const deleteStatusRule = `-- name: DeleteStatusRule :exec
DELETE FROM status_rule WHERE type = $1 AND name = $2
`

type DeleteStatusRuleParams struct {
	Type string
	Name string
}

func (q *Queries) DeleteStatusRule(ctx context.Context, arg DeleteStatusRuleParams) error {
	_, err := q.db.Exec(ctx, deleteStatusRule, arg.Type, arg.Name)
	return err
}

const dropACL = `-- name: DropACL :exec
DELETE FROM acl WHERE uuid = $1 AND uri = $2
`

type DropACLParams struct {
	UUID uuid.UUID
	URI  string
}

func (q *Queries) DropACL(ctx context.Context, arg DropACLParams) error {
	_, err := q.db.Exec(ctx, dropACL, arg.UUID, arg.URI)
	return err
}

const dropInvalidRestoreRequests = `-- name: DropInvalidRestoreRequests :exec
DELETE FROM restore_request AS rr
WHERE rr.finished IS NULL
AND rr.delete_record_id = ANY(
    SELECT dr.id FROM delete_record AS dr
    WHERE dr.id = rr.delete_record_id
    AND dr.purged IS NOT NULL
)
`

func (q *Queries) DropInvalidRestoreRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropInvalidRestoreRequests)
	return err
}

const dropMetaType = `-- name: DropMetaType :exec
DELETE FROM meta_type
WHERE meta_type = $1
`

func (q *Queries) DropMetaType(ctx context.Context, metaType string) error {
	_, err := q.db.Exec(ctx, dropMetaType, metaType)
	return err
}

const dropRedundantPurgeRequests = `-- name: DropRedundantPurgeRequests :exec
DELETE FROM purge_request AS pr
WHERE pr.finished IS NULL
AND pr.delete_record_id = ANY(
    SELECT dr.id FROM delete_record AS dr
    WHERE dr.id = pr.delete_record_id
    AND dr.purged IS NOT NULL
)
`

func (q *Queries) DropRedundantPurgeRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropRedundantPurgeRequests)
	return err
}

const finaliseDeleteRecord = `-- name: FinaliseDeleteRecord :exec
UPDATE delete_record SET finalised = $1
WHERE uuid = $2 AND id = $3
`

type FinaliseDeleteRecordParams struct {
	Finalised pgtype.Timestamptz
	UUID      uuid.UUID
	ID        int64
}

func (q *Queries) FinaliseDeleteRecord(ctx context.Context, arg FinaliseDeleteRecordParams) error {
	_, err := q.db.Exec(ctx, finaliseDeleteRecord, arg.Finalised, arg.UUID, arg.ID)
	return err
}

const finaliseDocumentDelete = `-- name: FinaliseDocumentDelete :execrows
DELETE FROM document
WHERE uuid = $1 AND system_state = 'deleting'
`

func (q *Queries) FinaliseDocumentDelete(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, finaliseDocumentDelete, argUuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const finishPurgeRequest = `-- name: FinishPurgeRequest :exec
UPDATE purge_request
SET finished = $1
WHERE id = $2
`

type FinishPurgeRequestParams struct {
	Finished pgtype.Timestamptz
	ID       int64
}

func (q *Queries) FinishPurgeRequest(ctx context.Context, arg FinishPurgeRequestParams) error {
	_, err := q.db.Exec(ctx, finishPurgeRequest, arg.Finished, arg.ID)
	return err
}

const finishRestoreRequest = `-- name: FinishRestoreRequest :exec
UPDATE restore_request
SET finished = $1
WHERE id = $2
`

type FinishRestoreRequestParams struct {
	Finished pgtype.Timestamptz
	ID       int64
}

func (q *Queries) FinishRestoreRequest(ctx context.Context, arg FinishRestoreRequestParams) error {
	_, err := q.db.Exec(ctx, finishRestoreRequest, arg.Finished, arg.ID)
	return err
}

const getActiveSchema = `-- name: GetActiveSchema :one
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
WHERE a.name = $1
`

func (q *Queries) GetActiveSchema(ctx context.Context, name string) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getActiveSchema, name)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getActiveSchemas = `-- name: GetActiveSchemas :many
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
`

func (q *Queries) GetActiveSchemas(ctx context.Context) ([]DocumentSchema, error) {
	rows, err := q.db.Query(ctx, getActiveSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentSchema
	for rows.Next() {
		var i DocumentSchema
		if err := rows.Scan(&i.Name, &i.Version, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStatuses = `-- name: GetActiveStatuses :many
SELECT type, name
FROM status
WHERE disabled = false
`

type GetActiveStatusesRow struct {
	Type string
	Name string
}

func (q *Queries) GetActiveStatuses(ctx context.Context) ([]GetActiveStatusesRow, error) {
	rows, err := q.db.Query(ctx, getActiveStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveStatusesRow
	for rows.Next() {
		var i GetActiveStatusesRow
		if err := rows.Scan(&i.Type, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompactedEventlog = `-- name: GetCompactedEventlog :many
SELECT
        w.id, w.event, w.uuid, w.timestamp, w.type, w.version, w.status,
        w.status_id, w.acl, w.updater, w.language, w.old_language, w.main_doc,
        w.system_state
FROM (
     SELECT DISTINCT ON (
            e.uuid,
            CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
            CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END
       ) id, event, uuid, timestamp, type, version, status, status_id, acl, updater, main_doc, language, old_language, system_state FROM eventlog AS e
     WHERE e.id > $1 AND e.id <= $2
     AND ($3::text IS NULL OR e.type = $3)
     ORDER BY
           e.uuid,
           CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
           CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END,
           e.id DESC
     ) AS w
ORDER BY w.id ASC
LIMIT $5 OFFSET $4
`

type GetCompactedEventlogParams struct {
	After     int64
	Until     int64
	Type      pgtype.Text
	RowOffset int32
	RowLimit  pgtype.Int4
}

type GetCompactedEventlogRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Updater     pgtype.Text
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
	SystemState pgtype.Text
}

func (q *Queries) GetCompactedEventlog(ctx context.Context, arg GetCompactedEventlogParams) ([]GetCompactedEventlogRow, error) {
	rows, err := q.db.Query(ctx, getCompactedEventlog,
		arg.After,
		arg.Until,
		arg.Type,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompactedEventlogRow
	for rows.Next() {
		var i GetCompactedEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
			&i.SystemState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentDocumentVersions = `-- name: GetCurrentDocumentVersions :many
SELECT uuid, current_version, updated
FROM document
WHERE uuid = ANY($1::uuid[])
`

type GetCurrentDocumentVersionsRow struct {
	UUID           uuid.UUID
	CurrentVersion int64
	Updated        pgtype.Timestamptz
}

func (q *Queries) GetCurrentDocumentVersions(ctx context.Context, uuids []uuid.UUID) ([]GetCurrentDocumentVersionsRow, error) {
	rows, err := q.db.Query(ctx, getCurrentDocumentVersions, uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentDocumentVersionsRow
	for rows.Next() {
		var i GetCurrentDocumentVersionsRow
		if err := rows.Scan(&i.UUID, &i.CurrentVersion, &i.Updated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeleteRecordForUpdate = `-- name: GetDeleteRecordForUpdate :one
SELECT id, uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, heads, finalised, purged
FROM delete_record
WHERE id = $1 AND uuid = $2
FOR UPDATE
`

type GetDeleteRecordForUpdateParams struct {
	ID   int64
	UUID uuid.UUID
}

type GetDeleteRecordForUpdateRow struct {
	ID            int64
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Heads         []byte
	Finalised     pgtype.Timestamptz
	Purged        pgtype.Timestamptz
}

func (q *Queries) GetDeleteRecordForUpdate(ctx context.Context, arg GetDeleteRecordForUpdateParams) (GetDeleteRecordForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDeleteRecordForUpdate, arg.ID, arg.UUID)
	var i GetDeleteRecordForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.URI,
		&i.Type,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.MainDoc,
		&i.Language,
		&i.MetaDocRecord,
		&i.Heads,
		&i.Finalised,
		&i.Purged,
	)
	return i, err
}

const getDeprecations = `-- name: GetDeprecations :many
SELECT label, enforced
FROM deprecation
ORDER BY label
`

func (q *Queries) GetDeprecations(ctx context.Context) ([]Deprecation, error) {
	rows, err := q.db.Query(ctx, getDeprecations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deprecation
	for rows.Next() {
		var i Deprecation
		if err := rows.Scan(&i.Label, &i.Enforced); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

func (q *Queries) GetDocumentACL(ctx context.Context, argUuid uuid.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.UUID, &i.URI, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentData = `-- name: GetDocumentData :one
SELECT v.document_data, v.version
FROM document as d
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid And v.version = d.current_version
WHERE d.uuid = $1
`

type GetDocumentDataRow struct {
	DocumentData []byte
	Version      int64
}

func (q *Queries) GetDocumentData(ctx context.Context, argUuid uuid.UUID) (GetDocumentDataRow, error) {
	row := q.db.QueryRow(ctx, getDocumentData, argUuid)
	var i GetDocumentDataRow
	err := row.Scan(&i.DocumentData, &i.Version)
	return i, err
}

const getDocumentForDeletion = `-- name: GetDocumentForDeletion :one
SELECT dr.id, dr.uuid, dr.heads, dr.acl, dr.version
FROM delete_record AS dr
WHERE dr.finalised IS NULL
ORDER BY dr.created
FOR UPDATE SKIP LOCKED -- locks both rows
LIMIT 1
`

type GetDocumentForDeletionRow struct {
	ID      int64
	UUID    uuid.UUID
	Heads   []byte
	Acl     []byte
	Version int64
}

func (q *Queries) GetDocumentForDeletion(ctx context.Context) (GetDocumentForDeletionRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForDeletion)
	var i GetDocumentForDeletionRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.Heads,
		&i.Acl,
		&i.Version,
	)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
SELECT d.uri, d.type, d.current_version, d.main_doc, d.language, d.system_state,
       l.uuid as lock_uuid, l.uri as lock_uri, l.created as lock_created,
       l.expires as lock_expires, l.app as lock_app, l.comment as lock_comment,
       l.token as lock_token
FROM document as d
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $2
WHERE d.uuid = $1
FOR UPDATE OF d
`

type GetDocumentForUpdateParams struct {
	UUID uuid.UUID
	Now  pgtype.Timestamptz
}

type GetDocumentForUpdateRow struct {
	URI            string
	Type           string
	CurrentVersion int64
	MainDoc        pgtype.UUID
	Language       pgtype.Text
	SystemState    pgtype.Text
	LockUuid       pgtype.UUID
	LockUri        pgtype.Text
	LockCreated    pgtype.Timestamptz
	LockExpires    pgtype.Timestamptz
	LockApp        pgtype.Text
	LockComment    pgtype.Text
	LockToken      pgtype.Text
}

func (q *Queries) GetDocumentForUpdate(ctx context.Context, arg GetDocumentForUpdateParams) (GetDocumentForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, arg.UUID, arg.Now)
	var i GetDocumentForUpdateRow
	err := row.Scan(
		&i.URI,
		&i.Type,
		&i.CurrentVersion,
		&i.MainDoc,
		&i.Language,
		&i.SystemState,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
	)
	return i, err
}

const getDocumentHeads = `-- name: GetDocumentHeads :many
SELECT name, current_id
FROM status_heads
WHERE uuid = $1
`

type GetDocumentHeadsRow struct {
	Name      string
	CurrentID int64
}

func (q *Queries) GetDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]GetDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentHeadsRow
	for rows.Next() {
		var i GetDocumentHeadsRow
		if err := rows.Scan(&i.Name, &i.CurrentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentInfo = `-- name: GetDocumentInfo :one
SELECT
        d.uuid, d.uri, d.created, creator_uri, updated, updater_uri, current_version,
        system_state, main_doc, l.uuid as lock_uuid, l.uri as lock_uri,
        l.created as lock_created, l.expires as lock_expires, l.app as lock_app,
        l.comment as lock_comment, l.token as lock_token
FROM document as d 
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $1
WHERE d.uuid = $2
`

type GetDocumentInfoParams struct {
	Now  pgtype.Timestamptz
	UUID uuid.UUID
}

type GetDocumentInfoRow struct {
	UUID           uuid.UUID
	URI            string
	Created        pgtype.Timestamptz
	CreatorUri     string
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	CurrentVersion int64
	SystemState    pgtype.Text
	MainDoc        pgtype.UUID
	LockUuid       pgtype.UUID
	LockUri        pgtype.Text
	LockCreated    pgtype.Timestamptz
	LockExpires    pgtype.Timestamptz
	LockApp        pgtype.Text
	LockComment    pgtype.Text
	LockToken      pgtype.Text
}

func (q *Queries) GetDocumentInfo(ctx context.Context, arg GetDocumentInfoParams) (GetDocumentInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentInfo, arg.Now, arg.UUID)
	var i GetDocumentInfoRow
	err := row.Scan(
		&i.UUID,
		&i.URI,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.SystemState,
		&i.MainDoc,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
	)
	return i, err
}

const getDocumentRow = `-- name: GetDocumentRow :one
SELECT uuid, uri, type, created, creator_uri, updated, updater_uri,
       current_version, main_doc, language, system_state
FROM document
WHERE uuid = $1
`

func (q *Queries) GetDocumentRow(ctx context.Context, argUuid uuid.UUID) (Document, error) {
	row := q.db.QueryRow(ctx, getDocumentRow, argUuid)
	var i Document
	err := row.Scan(
		&i.UUID,
		&i.URI,
		&i.Type,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.MainDoc,
		&i.Language,
		&i.SystemState,
	)
	return i, err
}

const getDocumentStatusForArchiving = `-- name: GetDocumentStatusForArchiving :one
SELECT
        s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
        p.signature AS parent_signature, v.signature AS version_signature,
        d.type, v.language, s.meta_doc_version
FROM document_status AS s
     INNER JOIN document AS d
           ON d.uuid = s.uuid
     LEFT JOIN document_version AS v
           ON v.uuid = s.uuid
              AND v.version = s.version
     LEFT JOIN document_status AS p
          ON p.uuid = s.uuid AND p.name = s.name AND p.id = s.id-1
WHERE s.archived = false
AND (s.id = 1 OR p.archived = true)
AND (s.version = -1 OR v.signature IS NOT NULL)
ORDER BY s.created
FOR UPDATE OF s SKIP LOCKED
LIMIT 1
`

type GetDocumentStatusForArchivingRow struct {
	UUID             uuid.UUID
	Name             string
	ID               int64
	Version          int64
	Created          pgtype.Timestamptz
	CreatorUri       string
	Meta             []byte
	ParentSignature  pgtype.Text
	VersionSignature pgtype.Text
	Type             string
	Language         pgtype.Text
	MetaDocVersion   pgtype.Int8
}

// Any parent has to have been archived.
// Accept null signature for the referenced version if we have a nil version.
func (q *Queries) GetDocumentStatusForArchiving(ctx context.Context) (GetDocumentStatusForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentStatusForArchiving)
	var i GetDocumentStatusForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Name,
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.ParentSignature,
		&i.VersionSignature,
		&i.Type,
		&i.Language,
		&i.MetaDocVersion,
	)
	return i, err
}

const getDocumentUnarchivedCount = `-- name: GetDocumentUnarchivedCount :one
SELECT SUM(num) FROM (
       SELECT COUNT(*) as num
              FROM document_status AS s
              WHERE s.uuid = $1 AND s.archived = false
       UNION
       SELECT COUNT(*) as num
              FROM document_version AS v
              WHERE v.uuid = $1 AND v.archived = false
) AS unarchived
`

func (q *Queries) GetDocumentUnarchivedCount(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getDocumentUnarchivedCount, argUuid)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getDocumentVersionData = `-- name: GetDocumentVersionData :one
SELECT document_data
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetDocumentVersionDataParams struct {
	UUID    uuid.UUID
	Version int64
}

func (q *Queries) GetDocumentVersionData(ctx context.Context, arg GetDocumentVersionDataParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionData, arg.UUID, arg.Version)
	var document_data []byte
	err := row.Scan(&document_data)
	return document_data, err
}

const getDocumentVersionForArchiving = `-- name: GetDocumentVersionForArchiving :one
SELECT
        v.uuid, v.version, v.created, v.creator_uri, v.meta, v.document_data,
        p.signature AS parent_signature, d.main_doc, d.uri, d.type,
        v.language AS language
FROM document_version AS v
     LEFT JOIN document_version AS p
          ON p.uuid = v.uuid AND p.version = v.version-1
     INNER JOIN document AS d
          ON d.uuid = v.uuid
WHERE v.archived = false
AND (v.version = 1 OR p.archived = true)
ORDER BY v.created
FOR UPDATE OF v SKIP LOCKED
LIMIT 1
`

type GetDocumentVersionForArchivingRow struct {
	UUID            uuid.UUID
	Version         int64
	Created         pgtype.Timestamptz
	CreatorUri      string
	Meta            []byte
	DocumentData    []byte
	ParentSignature pgtype.Text
	MainDoc         pgtype.UUID
	URI             string
	Type            string
	Language        pgtype.Text
}

func (q *Queries) GetDocumentVersionForArchiving(ctx context.Context) (GetDocumentVersionForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionForArchiving)
	var i GetDocumentVersionForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.ParentSignature,
		&i.MainDoc,
		&i.URI,
		&i.Type,
		&i.Language,
	)
	return i, err
}

const getEnforcedDeprecations = `-- name: GetEnforcedDeprecations :many
SELECT label
FROM deprecation
WHERE enforced = true
`

func (q *Queries) GetEnforcedDeprecations(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getEnforcedDeprecations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var label string
		if err := rows.Scan(&label); err != nil {
			return nil, err
		}
		items = append(items, label)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventlog = `-- name: GetEventlog :many
SELECT id, event, uuid, timestamp, type, version, status, status_id, acl, updater,
       language, old_language, main_doc, system_state
FROM eventlog
WHERE id > $1
ORDER BY id ASC
LIMIT $2
`

type GetEventlogParams struct {
	After    int64
	RowLimit int32
}

type GetEventlogRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Updater     pgtype.Text
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
	SystemState pgtype.Text
}

func (q *Queries) GetEventlog(ctx context.Context, arg GetEventlogParams) ([]GetEventlogRow, error) {
	rows, err := q.db.Query(ctx, getEventlog, arg.After, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventlogRow
	for rows.Next() {
		var i GetEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
			&i.SystemState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsinkPosition = `-- name: GetEventsinkPosition :one
SELECT position FROM eventsink WHERE name = $1
`

func (q *Queries) GetEventsinkPosition(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getEventsinkPosition, name)
	var position int64
	err := row.Scan(&position)
	return position, err
}

const getExpiredDocumentLocks = `-- name: GetExpiredDocumentLocks :many
SELECT d.uuid, l.expires AS lock_expires, l.app
FROM document_lock AS l
       INNER JOIN document AS d ON d.uuid = l.uuid
WHERE l.expires < $1
FOR UPDATE OF d SKIP LOCKED
`

type GetExpiredDocumentLocksRow struct {
	UUID        uuid.UUID
	LockExpires pgtype.Timestamptz
	App         pgtype.Text
}

func (q *Queries) GetExpiredDocumentLocks(ctx context.Context, cutoff pgtype.Timestamptz) ([]GetExpiredDocumentLocksRow, error) {
	rows, err := q.db.Query(ctx, getExpiredDocumentLocks, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredDocumentLocksRow
	for rows.Next() {
		var i GetExpiredDocumentLocksRow
		if err := rows.Scan(&i.UUID, &i.LockExpires, &i.App); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullDocumentHeads = `-- name: GetFullDocumentHeads :many
SELECT s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
       s.archived, s.signature, s.meta_doc_version
FROM status_heads AS h
     INNER JOIN document_status AS s ON
           s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = $1
`

func (q *Queries) GetFullDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getFullDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
			&i.Signature,
			&i.MetaDocVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullVersion = `-- name: GetFullVersion :one
SELECT created, creator_uri, meta, document_data, archived, signature
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetFullVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetFullVersionRow struct {
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Archived     bool
	Signature    pgtype.Text
}

func (q *Queries) GetFullVersion(ctx context.Context, arg GetFullVersionParams) (GetFullVersionRow, error) {
	row := q.db.QueryRow(ctx, getFullVersion, arg.UUID, arg.Version)
	var i GetFullVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.Archived,
		&i.Signature,
	)
	return i, err
}

const getInvalidRestoreRequests = `-- name: GetInvalidRestoreRequests :many
SELECT r.id
FROM restore_request AS r
     INNER JOIN delete_record AS dr
           ON dr.id = r.delete_record_id
WHERE r.finished IS NULL AND dr.purged IS NOT NULL
ORDER BY r.id ASC
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetInvalidRestoreRequests(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getInvalidRestoreRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobLock = `-- name: GetJobLock :one
SELECT holder, touched, iteration
FROM job_lock
WHERE name = $1
FOR UPDATE
`

type GetJobLockRow struct {
	Holder    string
	Touched   pgtype.Timestamptz
	Iteration int64
}

func (q *Queries) GetJobLock(ctx context.Context, name string) (GetJobLockRow, error) {
	row := q.db.QueryRow(ctx, getJobLock, name)
	var i GetJobLockRow
	err := row.Scan(&i.Holder, &i.Touched, &i.Iteration)
	return i, err
}

const getLastEvent = `-- name: GetLastEvent :one
SELECT id, event, uuid, timestamp, updater, type, version, status, status_id, acl,
       language, old_language, main_doc
FROM eventlog
ORDER BY id DESC
LIMIT 1
`

type GetLastEventRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Updater     pgtype.Text
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
}

func (q *Queries) GetLastEvent(ctx context.Context) (GetLastEventRow, error) {
	row := q.db.QueryRow(ctx, getLastEvent)
	var i GetLastEventRow
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.UUID,
		&i.Timestamp,
		&i.Updater,
		&i.Type,
		&i.Version,
		&i.Status,
		&i.StatusID,
		&i.Acl,
		&i.Language,
		&i.OldLanguage,
		&i.MainDoc,
	)
	return i, err
}

const getLastEventID = `-- name: GetLastEventID :one
SELECT id FROM eventlog
ORDER BY id DESC LIMIT 1
`

func (q *Queries) GetLastEventID(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLastEventID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getMetaDocVersion = `-- name: GetMetaDocVersion :one
SELECT current_version FROM document
WHERE main_doc = $1
`

func (q *Queries) GetMetaDocVersion(ctx context.Context, argUuid pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getMetaDocVersion, argUuid)
	var current_version int64
	err := row.Scan(&current_version)
	return current_version, err
}

const getMetricKind = `-- name: GetMetricKind :one
SELECT name, aggregation
FROM metric_kind 
WHERE name = $1
`

func (q *Queries) GetMetricKind(ctx context.Context, name string) (MetricKind, error) {
	row := q.db.QueryRow(ctx, getMetricKind, name)
	var i MetricKind
	err := row.Scan(&i.Name, &i.Aggregation)
	return i, err
}

const getMetricKinds = `-- name: GetMetricKinds :many
SELECT name, aggregation
FROM metric_kind 
ORDER BY name
`

func (q *Queries) GetMetricKinds(ctx context.Context) ([]MetricKind, error) {
	rows, err := q.db.Query(ctx, getMetricKinds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricKind
	for rows.Next() {
		var i MetricKind
		if err := rows.Scan(&i.Name, &i.Aggregation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMultipleStatusHeads = `-- name: GetMultipleStatusHeads :many
SELECT h.uuid, h.name, h.current_id, h.updated, h.updater_uri, s.version,
       s.meta_doc_version,
       CASE WHEN $1::bool THEN s.meta ELSE NULL::jsonb END AS meta
FROM status_heads AS h
     INNER JOIN document_status AS s
           ON s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = ANY($2::uuid[])
AND h.name = ANY($3::text[])
`

type GetMultipleStatusHeadsParams struct {
	GetMeta  bool
	Uuids    []uuid.UUID
	Statuses []string
}

type GetMultipleStatusHeadsRow struct {
	UUID           uuid.UUID
	Name           string
	CurrentID      int64
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	Version        int64
	MetaDocVersion pgtype.Int8
	Meta           []byte
}

func (q *Queries) GetMultipleStatusHeads(ctx context.Context, arg GetMultipleStatusHeadsParams) ([]GetMultipleStatusHeadsRow, error) {
	rows, err := q.db.Query(ctx, getMultipleStatusHeads, arg.GetMeta, arg.Uuids, arg.Statuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMultipleStatusHeadsRow
	for rows.Next() {
		var i GetMultipleStatusHeadsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.CurrentID,
			&i.Updated,
			&i.UpdaterUri,
			&i.Version,
			&i.MetaDocVersion,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextPurgeRequest = `-- name: GetNextPurgeRequest :one
SELECT p.id, p.uuid, p.delete_record_id, p.created
FROM purge_request AS p
     INNER JOIN delete_record AS dr
           ON dr.id = p.delete_record_id
WHERE p.finished IS NULL
      AND dr.purged IS NULL
      AND dr.finalised IS NOT NULL
ORDER BY p.id ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetNextPurgeRequestRow struct {
	ID             int64
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
}

func (q *Queries) GetNextPurgeRequest(ctx context.Context) (GetNextPurgeRequestRow, error) {
	row := q.db.QueryRow(ctx, getNextPurgeRequest)
	var i GetNextPurgeRequestRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.DeleteRecordID,
		&i.Created,
	)
	return i, err
}

const getNextRestoreRequest = `-- name: GetNextRestoreRequest :one
SELECT r.id, r.uuid, r.delete_record_id, r.created, r.creator, r.spec
FROM restore_request AS r
     INNER JOIN delete_record AS dr
           ON dr.id = r.delete_record_id
WHERE r.finished IS NULL AND dr.purged IS NULL
ORDER BY r.id ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetNextRestoreRequestRow struct {
	ID             int64
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
	Spec           []byte
}

func (q *Queries) GetNextRestoreRequest(ctx context.Context) (GetNextRestoreRequestRow, error) {
	row := q.db.QueryRow(ctx, getNextRestoreRequest)
	var i GetNextRestoreRequestRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.DeleteRecordID,
		&i.Created,
		&i.Creator,
		&i.Spec,
	)
	return i, err
}

const getPlanningAssignment = `-- name: GetPlanningAssignment :one
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
FROM planning_assignment
WHERE uuid = $1
`

func (q *Queries) GetPlanningAssignment(ctx context.Context, argUuid uuid.UUID) (PlanningAssignment, error) {
	row := q.db.QueryRow(ctx, getPlanningAssignment, argUuid)
	var i PlanningAssignment
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.PlanningItem,
		&i.Status,
		&i.Publish,
		&i.PublishSlot,
		&i.Starts,
		&i.Ends,
		&i.StartDate,
		&i.EndDate,
		&i.FullDay,
		&i.Public,
		&i.Kind,
		&i.Description,
	)
	return i, err
}

const getPlanningAssignments = `-- name: GetPlanningAssignments :many
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
FROM planning_assignment
WHERE planning_item = $1
`

func (q *Queries) GetPlanningAssignments(ctx context.Context, planningItem uuid.UUID) ([]PlanningAssignment, error) {
	rows, err := q.db.Query(ctx, getPlanningAssignments, planningItem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanningAssignment
	for rows.Next() {
		var i PlanningAssignment
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.PlanningItem,
			&i.Status,
			&i.Publish,
			&i.PublishSlot,
			&i.Starts,
			&i.Ends,
			&i.StartDate,
			&i.EndDate,
			&i.FullDay,
			&i.Public,
			&i.Kind,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanningItem = `-- name: GetPlanningItem :one
SELECT
        uuid, version, title, description, public, tentative,
        start_date, end_date, priority, event
FROM planning_item
WHERE uuid = $1
`

func (q *Queries) GetPlanningItem(ctx context.Context, argUuid uuid.UUID) (PlanningItem, error) {
	row := q.db.QueryRow(ctx, getPlanningItem, argUuid)
	var i PlanningItem
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Title,
		&i.Description,
		&i.Public,
		&i.Tentative,
		&i.StartDate,
		&i.EndDate,
		&i.Priority,
		&i.Event,
	)
	return i, err
}

const getSchema = `-- name: GetSchema :one
SELECT s.name, s.version, s.spec
FROM document_schema AS s
WHERE s.name = $1 AND s.version = $2
`

type GetSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) GetSchema(ctx context.Context, arg GetSchemaParams) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getSchema, arg.Name, arg.Version)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getSchemaVersions = `-- name: GetSchemaVersions :many
SELECT a.name, a.version
FROM active_schemas AS a
`

func (q *Queries) GetSchemaVersions(ctx context.Context) ([]ActiveSchema, error) {
	rows, err := q.db.Query(ctx, getSchemaVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveSchema
	for rows.Next() {
		var i ActiveSchema
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSigningKeys = `-- name: GetSigningKeys :many
SELECT kid, spec FROM signing_keys
`

func (q *Queries) GetSigningKeys(ctx context.Context) ([]SigningKey, error) {
	rows, err := q.db.Query(ctx, getSigningKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SigningKey
	for rows.Next() {
		var i SigningKey
		if err := rows.Scan(&i.Kid, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatus = `-- name: GetStatus :one
SELECT id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id = $3::bigint)
ORDER BY id DESC
LIMIT 1
`

type GetStatusParams struct {
	UUID uuid.UUID
	Name string
	ID   int64
}

type GetStatusRow struct {
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatus(ctx context.Context, arg GetStatusParams) (GetStatusRow, error) {
	row := q.db.QueryRow(ctx, getStatus, arg.UUID, arg.Name, arg.ID)
	var i GetStatusRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
	)
	return i, err
}

const getStatusRules = `-- name: GetStatusRules :many
SELECT type, name, description, access_rule, applies_to, expression
FROM status_rule
`

func (q *Queries) GetStatusRules(ctx context.Context) ([]StatusRule, error) {
	rows, err := q.db.Query(ctx, getStatusRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatusRule
	for rows.Next() {
		var i StatusRule
		if err := rows.Scan(
			&i.Type,
			&i.Name,
			&i.Description,
			&i.AccessRule,
			&i.AppliesTo,
			&i.Expression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusVersions = `-- name: GetStatusVersions :many
SELECT id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id < $3::bigint)
ORDER BY id DESC
LIMIT $4
`

type GetStatusVersionsParams struct {
	UUID   uuid.UUID
	Name   string
	Before int64
	Count  int32
}

type GetStatusVersionsRow struct {
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatusVersions(ctx context.Context, arg GetStatusVersionsParams) ([]GetStatusVersionsRow, error) {
	rows, err := q.db.Query(ctx, getStatusVersions,
		arg.UUID,
		arg.Name,
		arg.Before,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusVersionsRow
	for rows.Next() {
		var i GetStatusVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
SELECT uuid, name, id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetStatusesParams struct {
	UUID    uuid.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

type GetStatusesRow struct {
	UUID       uuid.UUID
	Name       string
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]GetStatusesRow, error) {
	rows, err := q.db.Query(ctx, getStatuses,
		arg.UUID,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesRow
	for rows.Next() {
		var i GetStatusesRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypeOfDocument = `-- name: GetTypeOfDocument :one
SELECT type
FROM document
WHERE uuid = $1
`

func (q *Queries) GetTypeOfDocument(ctx context.Context, argUuid uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getTypeOfDocument, argUuid)
	var type_ string
	err := row.Scan(&type_)
	return type_, err
}

const getVersion = `-- name: GetVersion :one
SELECT created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetVersionRow struct {
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersion(ctx context.Context, arg GetVersionParams) (GetVersionRow, error) {
	row := q.db.QueryRow(ctx, getVersion, arg.UUID, arg.Version)
	var i GetVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.Archived,
	)
	return i, err
}

const getVersionLanguage = `-- name: GetVersionLanguage :one
SELECT language FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionLanguageParams struct {
	UUID    uuid.UUID
	Version int64
}

func (q *Queries) GetVersionLanguage(ctx context.Context, arg GetVersionLanguageParams) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getVersionLanguage, arg.UUID, arg.Version)
	var language pgtype.Text
	err := row.Scan(&language)
	return language, err
}

const getVersions = `-- name: GetVersions :many
SELECT version, created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND ($2::bigint = 0 OR version < $2::bigint)
ORDER BY version DESC
LIMIT $3
`

type GetVersionsParams struct {
	UUID   uuid.UUID
	Before int64
	Count  int32
}

type GetVersionsRow struct {
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersions(ctx context.Context, arg GetVersionsParams) ([]GetVersionsRow, error) {
	rows, err := q.db.Query(ctx, getVersions, arg.UUID, arg.Before, arg.Count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsRow
	for rows.Next() {
		var i GetVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const granteesWithPermission = `-- name: GranteesWithPermission :many
SELECT uri
FROM acl
WHERE uuid = $1
      AND $2::text = ANY(permissions)
`

type GranteesWithPermissionParams struct {
	UUID       uuid.UUID
	Permission string
}

func (q *Queries) GranteesWithPermission(ctx context.Context, arg GranteesWithPermissionParams) ([]string, error) {
	rows, err := q.db.Query(ctx, granteesWithPermission, arg.UUID, arg.Permission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uri string
		if err := rows.Scan(&uri); err != nil {
			return nil, err
		}
		items = append(items, uri)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertACLAuditEntry = `-- name: InsertACLAuditEntry :exec
INSERT INTO acl_audit(
       uuid, type, updated,
       updater_uri, state, language,
       system_state
)
SELECT
       $1::uuid, $2, $3::timestamptz,
       $4::text, json_agg(l), $5::text,
       $6
FROM (
       SELECT uri, permissions
       FROM acl
       WHERE uuid = $1::uuid
) AS l
`

type InsertACLAuditEntryParams struct {
	UUID        uuid.UUID
	Type        pgtype.Text
	Updated     pgtype.Timestamptz
	UpdaterUri  string
	Language    string
	SystemState pgtype.Text
}

func (q *Queries) InsertACLAuditEntry(ctx context.Context, arg InsertACLAuditEntryParams) error {
	_, err := q.db.Exec(ctx, insertACLAuditEntry,
		arg.UUID,
		arg.Type,
		arg.Updated,
		arg.UpdaterUri,
		arg.Language,
		arg.SystemState,
	)
	return err
}

const insertDeleteRecord = `-- name: InsertDeleteRecord :one
INSERT INTO delete_record(
       uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, heads, acl
) VALUES(
       $1, $2, $3, $4, $5, $6, $7,
       $8, $9, $10, $11, $12
) RETURNING id
`

type InsertDeleteRecordParams struct {
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Heads         []byte
	Acl           []byte
}

func (q *Queries) InsertDeleteRecord(ctx context.Context, arg InsertDeleteRecordParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertDeleteRecord,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MainDoc,
		arg.Language,
		arg.MetaDocRecord,
		arg.Heads,
		arg.Acl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDeletionPlaceholder = `-- name: InsertDeletionPlaceholder :exec
insert into document(
       uuid, uri, type, created, creator_uri, updated, updater_uri,
       current_version, system_state
) values (
       $1, $2, '', now(), '', now(), '', $3, 'deleting'
)
`

type InsertDeletionPlaceholderParams struct {
	UUID     uuid.UUID
	URI      string
	RecordID int64
}

func (q *Queries) InsertDeletionPlaceholder(ctx context.Context, arg InsertDeletionPlaceholderParams) error {
	_, err := q.db.Exec(ctx, insertDeletionPlaceholder, arg.UUID, arg.URI, arg.RecordID)
	return err
}

const insertDocument = `-- name: InsertDocument :exec
INSERT INTO document(
       uuid, uri, type,
       created, creator_uri, updated, updater_uri, current_version,
       main_doc, language, system_state
) VALUES (
       $1, $2, $3,
       $4, $5, $4, $5, $6,
       $7, $8, $9
)
`

type InsertDocumentParams struct {
	UUID        uuid.UUID
	URI         string
	Type        string
	Created     pgtype.Timestamptz
	CreatorUri  string
	Version     int64
	MainDoc     pgtype.UUID
	Language    pgtype.Text
	SystemState pgtype.Text
}

func (q *Queries) InsertDocument(ctx context.Context, arg InsertDocumentParams) error {
	_, err := q.db.Exec(ctx, insertDocument,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Version,
		arg.MainDoc,
		arg.Language,
		arg.SystemState,
	)
	return err
}

const insertDocumentLock = `-- name: InsertDocumentLock :exec
INSERT INTO document_lock(
  uuid, token, created, expires, uri, app, comment
) VALUES(
  $1, $2, $3, $4, $5, $6, $7
)
`

type InsertDocumentLockParams struct {
	UUID    uuid.UUID
	Token   string
	Created pgtype.Timestamptz
	Expires pgtype.Timestamptz
	URI     pgtype.Text
	App     pgtype.Text
	Comment pgtype.Text
}

func (q *Queries) InsertDocumentLock(ctx context.Context, arg InsertDocumentLockParams) error {
	_, err := q.db.Exec(ctx, insertDocumentLock,
		arg.UUID,
		arg.Token,
		arg.Created,
		arg.Expires,
		arg.URI,
		arg.App,
		arg.Comment,
	)
	return err
}

const insertDocumentStatus = `-- name: InsertDocumentStatus :exec
INSERT INTO document_status(
       uuid, name, id, version, created,
       creator_uri, meta, meta_doc_version
) VALUES (
       $1, $2, $3, $4, $5,
       $6, $7, $8::bigint
)
`

type InsertDocumentStatusParams struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           []byte
	MetaDocVersion int64
}

func (q *Queries) InsertDocumentStatus(ctx context.Context, arg InsertDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, insertDocumentStatus,
		arg.UUID,
		arg.Name,
		arg.ID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MetaDocVersion,
	)
	return err
}

const insertIntoEventLog = `-- name: InsertIntoEventLog :one
INSERT INTO eventlog(
       event, uuid, type, timestamp, updater, version, status, status_id, acl,
       language, old_language, main_doc, system_state
) VALUES (
       $1, $2, $3, $4, $5, $6, $7, $8, $9,
       $10, $11, $12, $13
) RETURNING id
`

type InsertIntoEventLogParams struct {
	Event       string
	UUID        uuid.UUID
	Type        pgtype.Text
	Timestamp   pgtype.Timestamptz
	Updater     pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
	SystemState pgtype.Text
}

func (q *Queries) InsertIntoEventLog(ctx context.Context, arg InsertIntoEventLogParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertIntoEventLog,
		arg.Event,
		arg.UUID,
		arg.Type,
		arg.Timestamp,
		arg.Updater,
		arg.Version,
		arg.Status,
		arg.StatusID,
		arg.Acl,
		arg.Language,
		arg.OldLanguage,
		arg.MainDoc,
		arg.SystemState,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertJobLock = `-- name: InsertJobLock :one
INSERT INTO job_lock(name, holder, touched, iteration)
VALUES ($1, $2, now(), 1)
RETURNING iteration
`

type InsertJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) InsertJobLock(ctx context.Context, arg InsertJobLockParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertJobLock, arg.Name, arg.Holder)
	var iteration int64
	err := row.Scan(&iteration)
	return iteration, err
}

const insertPurgeRequest = `-- name: InsertPurgeRequest :exec
INSERT INTO purge_request(
       uuid, delete_record_id, created, creator
) VALUES(
       $1, $2, $3, $4
)
`

type InsertPurgeRequestParams struct {
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
}

func (q *Queries) InsertPurgeRequest(ctx context.Context, arg InsertPurgeRequestParams) error {
	_, err := q.db.Exec(ctx, insertPurgeRequest,
		arg.UUID,
		arg.DeleteRecordID,
		arg.Created,
		arg.Creator,
	)
	return err
}

const insertRestoreRequest = `-- name: InsertRestoreRequest :exec
INSERT INTO restore_request(
       uuid, delete_record_id, created, creator, spec
) VALUES(
       $1, $2, $3, $4, $5
)
`

type InsertRestoreRequestParams struct {
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
	Spec           []byte
}

func (q *Queries) InsertRestoreRequest(ctx context.Context, arg InsertRestoreRequestParams) error {
	_, err := q.db.Exec(ctx, insertRestoreRequest,
		arg.UUID,
		arg.DeleteRecordID,
		arg.Created,
		arg.Creator,
		arg.Spec,
	)
	return err
}

const insertSigningKey = `-- name: InsertSigningKey :exec
INSERT INTO signing_keys(kid, spec) VALUES($1, $2)
`

type InsertSigningKeyParams struct {
	Kid  string
	Spec []byte
}

func (q *Queries) InsertSigningKey(ctx context.Context, arg InsertSigningKeyParams) error {
	_, err := q.db.Exec(ctx, insertSigningKey, arg.Kid, arg.Spec)
	return err
}

const listDeleteRecords = `-- name: ListDeleteRecords :many
SELECT id, uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, finalised, purged
FROM delete_record AS r
WHERE ($1::uuid IS NULL OR r.uuid = $1)
      AND ($2::bigint = 0 OR r.id < $2)
      AND ($3::timestamptz IS NULL OR r.created < $3)
ORDER BY r.id DESC
`

type ListDeleteRecordsParams struct {
	UUID       pgtype.UUID
	BeforeID   int64
	BeforeTime pgtype.Timestamptz
}

type ListDeleteRecordsRow struct {
	ID            int64
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Finalised     pgtype.Timestamptz
	Purged        pgtype.Timestamptz
}

func (q *Queries) ListDeleteRecords(ctx context.Context, arg ListDeleteRecordsParams) ([]ListDeleteRecordsRow, error) {
	rows, err := q.db.Query(ctx, listDeleteRecords, arg.UUID, arg.BeforeID, arg.BeforeTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeleteRecordsRow
	for rows.Next() {
		var i ListDeleteRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.URI,
			&i.Type,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.MainDoc,
			&i.Language,
			&i.MetaDocRecord,
			&i.Finalised,
			&i.Purged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const pingJobLock = `-- name: PingJobLock :execrows
UPDATE job_lock
SET touched = now(),
    iteration = iteration + 1
WHERE name = $1
      AND holder = $2
      AND iteration = $3
`

type PingJobLockParams struct {
	Name      string
	Holder    string
	Iteration int64
}

func (q *Queries) PingJobLock(ctx context.Context, arg PingJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, pingJobLock, arg.Name, arg.Holder, arg.Iteration)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const purgeDeleteRecordDetails = `-- name: PurgeDeleteRecordDetails :exec
UPDATE delete_record SET
       meta = NULL, acl = NULL, heads = NULL, version = 0,
       language = NULL, 
       purged = $1
WHERE id = $2
`

type PurgeDeleteRecordDetailsParams struct {
	PurgedTime pgtype.Timestamptz
	ID         int64
}

func (q *Queries) PurgeDeleteRecordDetails(ctx context.Context, arg PurgeDeleteRecordDetailsParams) error {
	_, err := q.db.Exec(ctx, purgeDeleteRecordDetails, arg.PurgedTime, arg.ID)
	return err
}

const readForRestore = `-- name: ReadForRestore :one
SELECT system_state FROM document
WHERE uuid = $1
`

func (q *Queries) ReadForRestore(ctx context.Context, argUuid uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, readForRestore, argUuid)
	var system_state pgtype.Text
	err := row.Scan(&system_state)
	return system_state, err
}

const registerMetaType = `-- name: RegisterMetaType :exec
INSERT INTO meta_type(
       meta_type, exclusive_for_meta
) VALUES (
       $1, $2
) ON CONFLICT (meta_type) DO UPDATE SET
  exclusive_for_meta = $2
`

type RegisterMetaTypeParams struct {
	MetaType         string
	ExclusiveForMeta bool
}

func (q *Queries) RegisterMetaType(ctx context.Context, arg RegisterMetaTypeParams) error {
	_, err := q.db.Exec(ctx, registerMetaType, arg.MetaType, arg.ExclusiveForMeta)
	return err
}

const registerMetaTypeUse = `-- name: RegisterMetaTypeUse :exec
INSERT INTO meta_type_use(
       main_type, meta_type
) VALUES (
       $1, $2
)
`

type RegisterMetaTypeUseParams struct {
	MainType string
	MetaType string
}

func (q *Queries) RegisterMetaTypeUse(ctx context.Context, arg RegisterMetaTypeUseParams) error {
	_, err := q.db.Exec(ctx, registerMetaTypeUse, arg.MainType, arg.MetaType)
	return err
}

const registerMetricKind = `-- name: RegisterMetricKind :exec
INSERT INTO metric_kind(name, aggregation)
VALUES ($1, $2)
`

type RegisterMetricKindParams struct {
	Name        string
	Aggregation int16
}

func (q *Queries) RegisterMetricKind(ctx context.Context, arg RegisterMetricKindParams) error {
	_, err := q.db.Exec(ctx, registerMetricKind, arg.Name, arg.Aggregation)
	return err
}

const registerOrIncrementMetric = `-- name: RegisterOrIncrementMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = metric.value + $4
`

type RegisterOrIncrementMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrIncrementMetric(ctx context.Context, arg RegisterOrIncrementMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrIncrementMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerOrReplaceMetric = `-- name: RegisterOrReplaceMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = $4
`

type RegisterOrReplaceMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrReplaceMetric(ctx context.Context, arg RegisterOrReplaceMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrReplaceMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerSchema = `-- name: RegisterSchema :exec
INSERT INTO document_schema(name, version, spec)
VALUES ($1, $2, $3)
`

type RegisterSchemaParams struct {
	Name    string
	Version string
	Spec    []byte
}

func (q *Queries) RegisterSchema(ctx context.Context, arg RegisterSchemaParams) error {
	_, err := q.db.Exec(ctx, registerSchema, arg.Name, arg.Version, arg.Spec)
	return err
}

const releaseJobLock = `-- name: ReleaseJobLock :execrows
DELETE FROM job_lock
WHERE name = $1
      AND holder = $2
`

type ReleaseJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) ReleaseJobLock(ctx context.Context, arg ReleaseJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseJobLock, arg.Name, arg.Holder)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setDocumentStatusAsArchived = `-- name: SetDocumentStatusAsArchived :exec
UPDATE document_status
SET archived = true, signature = $1::text
WHERE uuid = $2 AND name = $3 AND id = $4
`

type SetDocumentStatusAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	Name      string
	ID        int64
}

func (q *Queries) SetDocumentStatusAsArchived(ctx context.Context, arg SetDocumentStatusAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentStatusAsArchived,
		arg.Signature,
		arg.UUID,
		arg.Name,
		arg.ID,
	)
	return err
}

const setDocumentVersionAsArchived = `-- name: SetDocumentVersionAsArchived :exec
UPDATE document_version
SET archived = true, signature = $1::text
WHERE uuid = $2 AND version = $3
`

type SetDocumentVersionAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	Version   int64
}

func (q *Queries) SetDocumentVersionAsArchived(ctx context.Context, arg SetDocumentVersionAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentVersionAsArchived, arg.Signature, arg.UUID, arg.Version)
	return err
}

const setPlanningAssignee = `-- name: SetPlanningAssignee :exec
INSERT INTO planning_assignee(
       assignment, assignee, version, role
) VALUES (
       $1, $2, $3, $4
)
ON CONFLICT ON CONSTRAINT planning_assignee_pkey DO UPDATE
SET version = $3, role = $4
`

type SetPlanningAssigneeParams struct {
	Assignment uuid.UUID
	Assignee   uuid.UUID
	Version    int64
	Role       string
}

func (q *Queries) SetPlanningAssignee(ctx context.Context, arg SetPlanningAssigneeParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignee,
		arg.Assignment,
		arg.Assignee,
		arg.Version,
		arg.Role,
	)
	return err
}

const setPlanningAssignment = `-- name: SetPlanningAssignment :exec
INSERT INTO planning_assignment(
       uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
) VALUES (
       $1, $2, $3, $4, $5, $6,
       $7, $8, $9, $10, $11, $12, $13,
       $14
)
ON CONFLICT ON CONSTRAINT planning_assignment_pkey DO UPDATE
SET
   version = $2, planning_item = $3, status = $4,
   publish = $5, publish_slot = $6, starts = $7,
   ends = $8, start_date = $9, end_date = $10,
   full_day = $11, public = $12, kind = $13,
   description = $14
`

type SetPlanningAssignmentParams struct {
	UUID         uuid.UUID
	Version      int64
	PlanningItem uuid.UUID
	Status       pgtype.Text
	Publish      pgtype.Timestamptz
	PublishSlot  pgtype.Int2
	Starts       pgtype.Timestamptz
	Ends         pgtype.Timestamptz
	StartDate    pgtype.Date
	EndDate      pgtype.Date
	FullDay      bool
	Public       bool
	Kind         []string
	Description  string
}

func (q *Queries) SetPlanningAssignment(ctx context.Context, arg SetPlanningAssignmentParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignment,
		arg.UUID,
		arg.Version,
		arg.PlanningItem,
		arg.Status,
		arg.Publish,
		arg.PublishSlot,
		arg.Starts,
		arg.Ends,
		arg.StartDate,
		arg.EndDate,
		arg.FullDay,
		arg.Public,
		arg.Kind,
		arg.Description,
	)
	return err
}

const setPlanningItem = `-- name: SetPlanningItem :exec
INSERT INTO planning_item(
        uuid, version, title, description, tentative,
        start_date, end_date, priority, event
) VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9
)
ON CONFLICT ON CONSTRAINT planning_item_pkey DO UPDATE
SET
   version = $2, title = $3, description = $4,
   public = $10, tentative = $5, start_date = $6,
   end_date = $7, priority = $8, event = $9
`

type SetPlanningItemParams struct {
	UUID        uuid.UUID
	Version     int64
	Title       string
	Description string
	Tentative   bool
	StartDate   pgtype.Date
	EndDate     pgtype.Date
	Priority    pgtype.Int2
	Event       pgtype.UUID
	Public      pgtype.Bool
}

func (q *Queries) SetPlanningItem(ctx context.Context, arg SetPlanningItemParams) error {
	_, err := q.db.Exec(ctx, setPlanningItem,
		arg.UUID,
		arg.Version,
		arg.Title,
		arg.Description,
		arg.Tentative,
		arg.StartDate,
		arg.EndDate,
		arg.Priority,
		arg.Event,
		arg.Public,
	)
	return err
}

const setPlanningItemDeliverable = `-- name: SetPlanningItemDeliverable :exec
INSERT INTO planning_deliverable(
       assignment, document, version
) VALUES(
       $1, $2, $3
)
ON CONFLICT ON CONSTRAINT planning_deliverable_pkey DO UPDATE
SET
   version = $3
`

type SetPlanningItemDeliverableParams struct {
	Assignment uuid.UUID
	Document   uuid.UUID
	Version    int64
}

func (q *Queries) SetPlanningItemDeliverable(ctx context.Context, arg SetPlanningItemDeliverableParams) error {
	_, err := q.db.Exec(ctx, setPlanningItemDeliverable, arg.Assignment, arg.Document, arg.Version)
	return err
}

const stealJobLock = `-- name: StealJobLock :execrows
UPDATE job_lock
SET holder = $1,
    touched = now(),
    iteration = iteration + 1
WHERE name = $2
      AND holder = $3
      AND iteration = $4
`

type StealJobLockParams struct {
	NewHolder      string
	Name           string
	PreviousHolder string
	Iteration      int64
}

func (q *Queries) StealJobLock(ctx context.Context, arg StealJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, stealJobLock,
		arg.NewHolder,
		arg.Name,
		arg.PreviousHolder,
		arg.Iteration,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateDeprecation = `-- name: UpdateDeprecation :exec
INSERT INTO deprecation(label, enforced)
VALUES($1, $2)
ON CONFLICT(label) DO UPDATE SET
   enforced = $2
`

type UpdateDeprecationParams struct {
	Label    string
	Enforced bool
}

func (q *Queries) UpdateDeprecation(ctx context.Context, arg UpdateDeprecationParams) error {
	_, err := q.db.Exec(ctx, updateDeprecation, arg.Label, arg.Enforced)
	return err
}

const updateDocumentLock = `-- name: UpdateDocumentLock :exec
UPDATE document_lock
SET expires = $1
WHERE uuid = $2
`

type UpdateDocumentLockParams struct {
	Expires pgtype.Timestamptz
	UUID    uuid.UUID
}

func (q *Queries) UpdateDocumentLock(ctx context.Context, arg UpdateDocumentLockParams) error {
	_, err := q.db.Exec(ctx, updateDocumentLock, arg.Expires, arg.UUID)
	return err
}

const updateEventsinkPosition = `-- name: UpdateEventsinkPosition :exec
UPDATE eventsink SET position = $1 WHERE name = $2
`

type UpdateEventsinkPositionParams struct {
	Position int64
	Name     string
}

func (q *Queries) UpdateEventsinkPosition(ctx context.Context, arg UpdateEventsinkPositionParams) error {
	_, err := q.db.Exec(ctx, updateEventsinkPosition, arg.Position, arg.Name)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
INSERT INTO status(type, name, disabled)
VALUES($1, $2, $3)
ON CONFLICT(type, name) DO UPDATE SET
   disabled = $3
`

type UpdateStatusParams struct {
	Type     string
	Name     string
	Disabled bool
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Type, arg.Name, arg.Disabled)
	return err
}

const updateStatusRule = `-- name: UpdateStatusRule :exec
INSERT INTO status_rule(
       type, name, description, access_rule, applies_to, expression
) VALUES(
       $1, $2, $3, $4, $5, $6
) ON CONFLICT(type, name)
  DO UPDATE SET
     description = $3, access_rule = $4,
     applies_to = $5, expression = $6
`

type UpdateStatusRuleParams struct {
	Type        string
	Name        string
	Description string
	AccessRule  bool
	AppliesTo   []string
	Expression  string
}

func (q *Queries) UpdateStatusRule(ctx context.Context, arg UpdateStatusRuleParams) error {
	_, err := q.db.Exec(ctx, updateStatusRule,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.AccessRule,
		arg.AppliesTo,
		arg.Expression,
	)
	return err
}

const upsertDocument = `-- name: UpsertDocument :exec
INSERT INTO document(
       uuid, uri, type,
       created, creator_uri, updated, updater_uri, current_version,
       main_doc, language
) VALUES (
       $1, $2, $3,
       $4, $5, $4, $5, $6,
       $7, $8
) ON CONFLICT (uuid) DO UPDATE
     SET uri = $2,
         updated = $4,
         updater_uri = $5,
         current_version = $6,
         language = $8
`

type UpsertDocumentParams struct {
	UUID       uuid.UUID
	URI        string
	Type       string
	Created    pgtype.Timestamptz
	CreatorUri string
	Version    int64
	MainDoc    pgtype.UUID
	Language   pgtype.Text
}

func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Version,
		arg.MainDoc,
		arg.Language,
	)
	return err
}
