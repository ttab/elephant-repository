// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireTXLock = `-- name: AcquireTXLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireTXLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, acquireTXLock, id)
	return err
}

const activateSchema = `-- name: ActivateSchema :exec
INSERT INTO active_schemas(name, version)
VALUES ($1, $2)
       ON CONFLICT(name) DO UPDATE SET
          version = $2
`

type ActivateSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) ActivateSchema(ctx context.Context, arg ActivateSchemaParams) error {
	_, err := q.db.Exec(ctx, activateSchema, arg.Name, arg.Version)
	return err
}

const checkMetaDocumentType = `-- name: CheckMetaDocumentType :one
SELECT coalesce(meta_type, ''), NOT d.main_doc IS NULL as is_meta_doc
FROM document AS d
     LEFT JOIN meta_type_use AS m ON m.main_type = d.type
WHERE d.uuid = $1
`

type CheckMetaDocumentTypeRow struct {
	MetaType  string
	IsMetaDoc pgtype.Bool
}

func (q *Queries) CheckMetaDocumentType(ctx context.Context, argUuid uuid.UUID) (CheckMetaDocumentTypeRow, error) {
	row := q.db.QueryRow(ctx, checkMetaDocumentType, argUuid)
	var i CheckMetaDocumentTypeRow
	err := row.Scan(&i.MetaType, &i.IsMetaDoc)
	return i, err
}

const checkPermissions = `-- name: CheckPermissions :one
SELECT (acl.uri IS NOT NULL) = true AS has_access
FROM document AS d
     LEFT JOIN acl
          ON (acl.uuid = d.uuid OR acl.uuid = d.main_doc)
          AND acl.uri = ANY($1::text[])
          AND $2::text[] && permissions
WHERE d.uuid = $3
`

type CheckPermissionsParams struct {
	URI         []string
	Permissions []string
	UUID        uuid.UUID
}

func (q *Queries) CheckPermissions(ctx context.Context, arg CheckPermissionsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPermissions, arg.URI, arg.Permissions, arg.UUID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const cleanUpAssignees = `-- name: CleanUpAssignees :exec
DELETE FROM planning_assignee
WHERE assignment = $1 AND version != $2
`

type CleanUpAssigneesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpAssignees(ctx context.Context, arg CleanUpAssigneesParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignees, arg.Assignment, arg.Version)
	return err
}

const cleanUpAssignments = `-- name: CleanUpAssignments :exec
DELETE FROM planning_assignment
WHERE planning_item = $1 AND version != $2
`

type CleanUpAssignmentsParams struct {
	PlanningItem uuid.UUID
	Version      int64
}

func (q *Queries) CleanUpAssignments(ctx context.Context, arg CleanUpAssignmentsParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignments, arg.PlanningItem, arg.Version)
	return err
}

const cleanUpDeliverables = `-- name: CleanUpDeliverables :exec
DELETE FROM planning_deliverable
WHERE assignment = $1 AND version != $2
`

type CleanUpDeliverablesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpDeliverables(ctx context.Context, arg CleanUpDeliverablesParams) error {
	_, err := q.db.Exec(ctx, cleanUpDeliverables, arg.Assignment, arg.Version)
	return err
}

const configureEventsink = `-- name: ConfigureEventsink :exec
INSERT INTO eventsink(name, configuration) VALUES($1, $2)
ON CONFLICT (name) DO UPDATE SET
   configuration = $2
`

type ConfigureEventsinkParams struct {
	Name   string
	Config []byte
}

func (q *Queries) ConfigureEventsink(ctx context.Context, arg ConfigureEventsinkParams) error {
	_, err := q.db.Exec(ctx, configureEventsink, arg.Name, arg.Config)
	return err
}

const createDocumentVersion = `-- name: CreateDocumentVersion :exec
INSERT INTO document_version(
       uuid, version,
       created, creator_uri, meta, document_data, archived
) VALUES (
       $1, $2,
       $3, $4, $5, $6, false
)
`

type CreateDocumentVersionParams struct {
	UUID         uuid.UUID
	Version      int64
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
}

func (q *Queries) CreateDocumentVersion(ctx context.Context, arg CreateDocumentVersionParams) error {
	_, err := q.db.Exec(ctx, createDocumentVersion,
		arg.UUID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.DocumentData,
	)
	return err
}

const createStatusHead = `-- name: CreateStatusHead :exec
INSERT INTO status_heads(
       uuid, name, type, version, current_id,
       updated, updater_uri, language
) VALUES (
       $1, $2, $3::text, $4::bigint, $5::bigint,
       $6, $7, $8::text
)
ON CONFLICT (uuid, name) DO UPDATE
   SET updated = $6,
       updater_uri = $7,
       current_id = $5::bigint,
       version = $4::bigint,
       language = $8::text
`

type CreateStatusHeadParams struct {
	UUID       uuid.UUID
	Name       string
	Type       string
	Version    int64
	ID         int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Language   string
}

func (q *Queries) CreateStatusHead(ctx context.Context, arg CreateStatusHeadParams) error {
	_, err := q.db.Exec(ctx, createStatusHead,
		arg.UUID,
		arg.Name,
		arg.Type,
		arg.Version,
		arg.ID,
		arg.Created,
		arg.CreatorUri,
		arg.Language,
	)
	return err
}

const deactivateSchema = `-- name: DeactivateSchema :exec
DELETE FROM active_schemas
WHERE name = $1
`

func (q *Queries) DeactivateSchema(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deactivateSchema, name)
	return err
}

const deleteDocument = `-- name: DeleteDocument :exec
SELECT delete_document(
       $1::uuid, $2::text, $3::bigint
)
`

type DeleteDocumentParams struct {
	UUID     uuid.UUID
	URI      string
	RecordID int64
}

func (q *Queries) DeleteDocument(ctx context.Context, arg DeleteDocumentParams) error {
	_, err := q.db.Exec(ctx, deleteDocument, arg.UUID, arg.URI, arg.RecordID)
	return err
}

const deleteDocumentLock = `-- name: DeleteDocumentLock :execrows
DELETE FROM document_lock
WHERE uuid = $1
  AND token = $2
`

type DeleteDocumentLockParams struct {
	UUID  uuid.UUID
	Token string
}

func (q *Queries) DeleteDocumentLock(ctx context.Context, arg DeleteDocumentLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteDocumentLock, arg.UUID, arg.Token)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredDocumentLock = `-- name: DeleteExpiredDocumentLock :exec
DELETE FROM document_lock
WHERE uuid = ANY($1::uuid[])
  AND expires < $2
`

type DeleteExpiredDocumentLockParams struct {
	Uuids  []uuid.UUID
	Cutoff pgtype.Timestamptz
}

func (q *Queries) DeleteExpiredDocumentLock(ctx context.Context, arg DeleteExpiredDocumentLockParams) error {
	_, err := q.db.Exec(ctx, deleteExpiredDocumentLock, arg.Uuids, arg.Cutoff)
	return err
}

const deleteMetricKind = `-- name: DeleteMetricKind :exec
DELETE FROM metric_kind
WHERE name = $1
`

func (q *Queries) DeleteMetricKind(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteMetricKind, name)
	return err
}

const deletePlanningItem = `-- name: DeletePlanningItem :exec
DELETE FROM planning_item WHERE uuid = $1
`

func (q *Queries) DeletePlanningItem(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlanningItem, argUuid)
	return err
}

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM report
WHERE name = $1
`

func (q *Queries) DeleteReport(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteReport, name)
	return err
}

const deleteStatusRule = `-- name: DeleteStatusRule :exec
DELETE FROM status_rule WHERE name = $1
`

func (q *Queries) DeleteStatusRule(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteStatusRule, name)
	return err
}

const dropACL = `-- name: DropACL :exec
DELETE FROM acl WHERE uuid = $1 AND uri = $2
`

type DropACLParams struct {
	UUID uuid.UUID
	URI  string
}

func (q *Queries) DropACL(ctx context.Context, arg DropACLParams) error {
	_, err := q.db.Exec(ctx, dropACL, arg.UUID, arg.URI)
	return err
}

const dropMetaType = `-- name: DropMetaType :exec
DELETE FROM meta_type
WHERE meta_type = $1
`

func (q *Queries) DropMetaType(ctx context.Context, metaType string) error {
	_, err := q.db.Exec(ctx, dropMetaType, metaType)
	return err
}

const finaliseDelete = `-- name: FinaliseDelete :execrows
DELETE FROM document
WHERE uuid = $1 AND deleting = true
`

func (q *Queries) FinaliseDelete(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, finaliseDelete, argUuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveSchema = `-- name: GetActiveSchema :one
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
WHERE a.name = $1
`

func (q *Queries) GetActiveSchema(ctx context.Context, name string) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getActiveSchema, name)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getActiveSchemas = `-- name: GetActiveSchemas :many
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
`

func (q *Queries) GetActiveSchemas(ctx context.Context) ([]DocumentSchema, error) {
	rows, err := q.db.Query(ctx, getActiveSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentSchema
	for rows.Next() {
		var i DocumentSchema
		if err := rows.Scan(&i.Name, &i.Version, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStatuses = `-- name: GetActiveStatuses :many
SELECT name
FROM status
WHERE disabled = false
`

func (q *Queries) GetActiveStatuses(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getActiveStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompactedEventlog = `-- name: GetCompactedEventlog :many
SELECT
        w.id, w.event, w.uuid, w.timestamp, w.type, w.version, w.status,
        w.status_id, w.acl, w.updater, w.language, w.old_language, w.main_doc
FROM (
     SELECT DISTINCT ON (
            e.uuid,
            CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
            CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END
       ) id, event, uuid, timestamp, type, version, status, status_id, acl, updater, main_doc, language, old_language FROM eventlog AS e
     WHERE e.id > $1 AND e.id <= $2
     AND ($3::text IS NULL OR e.type = $3)
     ORDER BY
           e.uuid,
           CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
           CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END,
           e.id DESC
     ) AS w
ORDER BY w.id ASC
LIMIT $5 OFFSET $4
`

type GetCompactedEventlogParams struct {
	After     int64
	Until     int64
	Type      pgtype.Text
	RowOffset int32
	RowLimit  pgtype.Int4
}

type GetCompactedEventlogRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Updater     pgtype.Text
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
}

func (q *Queries) GetCompactedEventlog(ctx context.Context, arg GetCompactedEventlogParams) ([]GetCompactedEventlogRow, error) {
	rows, err := q.db.Query(ctx, getCompactedEventlog,
		arg.After,
		arg.Until,
		arg.Type,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompactedEventlogRow
	for rows.Next() {
		var i GetCompactedEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

func (q *Queries) GetDocumentACL(ctx context.Context, argUuid uuid.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.UUID, &i.URI, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentData = `-- name: GetDocumentData :one
SELECT v.document_data, v.version
FROM document as d
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid And v.version = d.current_version
WHERE d.uuid = $1
`

type GetDocumentDataRow struct {
	DocumentData []byte
	Version      int64
}

func (q *Queries) GetDocumentData(ctx context.Context, argUuid uuid.UUID) (GetDocumentDataRow, error) {
	row := q.db.QueryRow(ctx, getDocumentData, argUuid)
	var i GetDocumentDataRow
	err := row.Scan(&i.DocumentData, &i.Version)
	return i, err
}

const getDocumentForDeletion = `-- name: GetDocumentForDeletion :one
SELECT uuid, current_version AS delete_record_id FROM document
WHERE deleting = true
ORDER BY created
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetDocumentForDeletionRow struct {
	UUID           uuid.UUID
	DeleteRecordID int64
}

func (q *Queries) GetDocumentForDeletion(ctx context.Context) (GetDocumentForDeletionRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForDeletion)
	var i GetDocumentForDeletionRow
	err := row.Scan(&i.UUID, &i.DeleteRecordID)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
SELECT d.uri, d.type, d.current_version, d.deleting, d.main_doc, d.language,
       l.uuid as lock_uuid, l.uri as lock_uri, l.created as lock_created,
       l.expires as lock_expires, l.app as lock_app, l.comment as lock_comment,
       l.token as lock_token
FROM document as d
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $2
WHERE d.uuid = $1
FOR UPDATE OF d
`

type GetDocumentForUpdateParams struct {
	UUID uuid.UUID
	Now  pgtype.Timestamptz
}

type GetDocumentForUpdateRow struct {
	URI            string
	Type           string
	CurrentVersion int64
	Deleting       bool
	MainDoc        pgtype.UUID
	Language       pgtype.Text
	LockUuid       pgtype.UUID
	LockUri        pgtype.Text
	LockCreated    pgtype.Timestamptz
	LockExpires    pgtype.Timestamptz
	LockApp        pgtype.Text
	LockComment    pgtype.Text
	LockToken      pgtype.Text
}

func (q *Queries) GetDocumentForUpdate(ctx context.Context, arg GetDocumentForUpdateParams) (GetDocumentForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, arg.UUID, arg.Now)
	var i GetDocumentForUpdateRow
	err := row.Scan(
		&i.URI,
		&i.Type,
		&i.CurrentVersion,
		&i.Deleting,
		&i.MainDoc,
		&i.Language,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
	)
	return i, err
}

const getDocumentHeads = `-- name: GetDocumentHeads :many
SELECT name, current_id
FROM status_heads
WHERE uuid = $1
`

type GetDocumentHeadsRow struct {
	Name      string
	CurrentID int64
}

func (q *Queries) GetDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]GetDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentHeadsRow
	for rows.Next() {
		var i GetDocumentHeadsRow
		if err := rows.Scan(&i.Name, &i.CurrentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentInfo = `-- name: GetDocumentInfo :one
SELECT
        d.uuid, d.uri, d.created, creator_uri, updated, updater_uri, current_version,
        deleting, main_doc, l.uuid as lock_uuid, l.uri as lock_uri,
        l.created as lock_created, l.expires as lock_expires, l.app as lock_app,
        l.comment as lock_comment, l.token as lock_token
FROM document as d 
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $1
WHERE d.uuid = $2
`

type GetDocumentInfoParams struct {
	Now  pgtype.Timestamptz
	UUID uuid.UUID
}

type GetDocumentInfoRow struct {
	UUID           uuid.UUID
	URI            string
	Created        pgtype.Timestamptz
	CreatorUri     string
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	CurrentVersion int64
	Deleting       bool
	MainDoc        pgtype.UUID
	LockUuid       pgtype.UUID
	LockUri        pgtype.Text
	LockCreated    pgtype.Timestamptz
	LockExpires    pgtype.Timestamptz
	LockApp        pgtype.Text
	LockComment    pgtype.Text
	LockToken      pgtype.Text
}

func (q *Queries) GetDocumentInfo(ctx context.Context, arg GetDocumentInfoParams) (GetDocumentInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentInfo, arg.Now, arg.UUID)
	var i GetDocumentInfoRow
	err := row.Scan(
		&i.UUID,
		&i.URI,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.Deleting,
		&i.MainDoc,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
	)
	return i, err
}

const getDocumentStatusForArchiving = `-- name: GetDocumentStatusForArchiving :one
SELECT
        s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
        p.signature AS parent_signature, v.signature AS version_signature
FROM document_status AS s
     INNER JOIN document_version AS v
           ON v.uuid = s.uuid
              AND v.version = s.version
              AND v.signature IS NOT NULL
     LEFT JOIN document_status AS p
          ON p.uuid = s.uuid AND p.name = s.name AND p.id = s.id-1
WHERE s.archived = false
AND (s.id = 1 OR p.archived = true)
ORDER BY s.created
FOR UPDATE OF s SKIP LOCKED
LIMIT 1
`

type GetDocumentStatusForArchivingRow struct {
	UUID             uuid.UUID
	Name             string
	ID               int64
	Version          int64
	Created          pgtype.Timestamptz
	CreatorUri       string
	Meta             []byte
	ParentSignature  pgtype.Text
	VersionSignature pgtype.Text
}

func (q *Queries) GetDocumentStatusForArchiving(ctx context.Context) (GetDocumentStatusForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentStatusForArchiving)
	var i GetDocumentStatusForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Name,
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.ParentSignature,
		&i.VersionSignature,
	)
	return i, err
}

const getDocumentUnarchivedCount = `-- name: GetDocumentUnarchivedCount :one
SELECT SUM(num) FROM (
       SELECT COUNT(*) as num
              FROM document_status AS s
              WHERE s.uuid = $1 AND s.archived = false
       UNION
       SELECT COUNT(*) as num
              FROM document_version AS v
              WHERE v.uuid = $1 AND v.archived = false
) AS unarchived
`

func (q *Queries) GetDocumentUnarchivedCount(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getDocumentUnarchivedCount, argUuid)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getDocumentVersionData = `-- name: GetDocumentVersionData :one
SELECT document_data
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetDocumentVersionDataParams struct {
	UUID    uuid.UUID
	Version int64
}

func (q *Queries) GetDocumentVersionData(ctx context.Context, arg GetDocumentVersionDataParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionData, arg.UUID, arg.Version)
	var document_data []byte
	err := row.Scan(&document_data)
	return document_data, err
}

const getDocumentVersionForArchiving = `-- name: GetDocumentVersionForArchiving :one
SELECT
        v.uuid, v.version, v.created, v.creator_uri, v.meta, v.document_data,
        p.signature AS parent_signature
FROM document_version AS v
     LEFT JOIN document_version AS p
          ON p.uuid = v.uuid AND p.version = v.version-1
WHERE v.archived = false
AND (v.version = 1 OR p.archived = true)
ORDER BY v.created
FOR UPDATE OF v SKIP LOCKED
LIMIT 1
`

type GetDocumentVersionForArchivingRow struct {
	UUID            uuid.UUID
	Version         int64
	Created         pgtype.Timestamptz
	CreatorUri      string
	Meta            []byte
	DocumentData    []byte
	ParentSignature pgtype.Text
}

func (q *Queries) GetDocumentVersionForArchiving(ctx context.Context) (GetDocumentVersionForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionForArchiving)
	var i GetDocumentVersionForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.ParentSignature,
	)
	return i, err
}

const getDueReport = `-- name: GetDueReport :one
SELECT name, enabled, next_execution, spec
FROM report
WHERE enabled AND next_execution < now()
FOR UPDATE SKIP LOCKED
LIMIT 1
`

func (q *Queries) GetDueReport(ctx context.Context) (Report, error) {
	row := q.db.QueryRow(ctx, getDueReport)
	var i Report
	err := row.Scan(
		&i.Name,
		&i.Enabled,
		&i.NextExecution,
		&i.Spec,
	)
	return i, err
}

const getEventlog = `-- name: GetEventlog :many
SELECT id, event, uuid, timestamp, type, version, status, status_id, acl, updater,
       language, old_language, main_doc
FROM eventlog
WHERE id > $1
ORDER BY id ASC
LIMIT $2
`

type GetEventlogParams struct {
	After    int64
	RowLimit int32
}

type GetEventlogRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Updater     pgtype.Text
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
}

func (q *Queries) GetEventlog(ctx context.Context, arg GetEventlogParams) ([]GetEventlogRow, error) {
	rows, err := q.db.Query(ctx, getEventlog, arg.After, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventlogRow
	for rows.Next() {
		var i GetEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsinkPosition = `-- name: GetEventsinkPosition :one
SELECT position FROM eventsink WHERE name = $1
`

func (q *Queries) GetEventsinkPosition(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getEventsinkPosition, name)
	var position int64
	err := row.Scan(&position)
	return position, err
}

const getExpiredDocumentLocks = `-- name: GetExpiredDocumentLocks :many
SELECT d.uuid, l.expires AS lock_expires, l.app
FROM document_lock AS l
       INNER JOIN document AS d ON d.uuid = l.uuid
WHERE l.expires < $1
FOR UPDATE OF d SKIP LOCKED
`

type GetExpiredDocumentLocksRow struct {
	UUID        uuid.UUID
	LockExpires pgtype.Timestamptz
	App         pgtype.Text
}

func (q *Queries) GetExpiredDocumentLocks(ctx context.Context, cutoff pgtype.Timestamptz) ([]GetExpiredDocumentLocksRow, error) {
	rows, err := q.db.Query(ctx, getExpiredDocumentLocks, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredDocumentLocksRow
	for rows.Next() {
		var i GetExpiredDocumentLocksRow
		if err := rows.Scan(&i.UUID, &i.LockExpires, &i.App); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullDocumentHeads = `-- name: GetFullDocumentHeads :many
SELECT s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
       s.archived, s.signature, s.meta_doc_version
FROM status_heads AS h
     INNER JOIN document_status AS s ON
           s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = $1
`

func (q *Queries) GetFullDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getFullDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
			&i.Signature,
			&i.MetaDocVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullVersion = `-- name: GetFullVersion :one
SELECT created, creator_uri, meta, document_data, archived, signature
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetFullVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetFullVersionRow struct {
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Archived     bool
	Signature    pgtype.Text
}

func (q *Queries) GetFullVersion(ctx context.Context, arg GetFullVersionParams) (GetFullVersionRow, error) {
	row := q.db.QueryRow(ctx, getFullVersion, arg.UUID, arg.Version)
	var i GetFullVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.Archived,
		&i.Signature,
	)
	return i, err
}

const getJobLock = `-- name: GetJobLock :one
SELECT holder, touched, iteration
FROM job_lock
WHERE name = $1
FOR UPDATE
`

type GetJobLockRow struct {
	Holder    string
	Touched   pgtype.Timestamptz
	Iteration int64
}

func (q *Queries) GetJobLock(ctx context.Context, name string) (GetJobLockRow, error) {
	row := q.db.QueryRow(ctx, getJobLock, name)
	var i GetJobLockRow
	err := row.Scan(&i.Holder, &i.Touched, &i.Iteration)
	return i, err
}

const getLastEvent = `-- name: GetLastEvent :one
SELECT id, event, uuid, timestamp, updater, type, version, status, status_id, acl,
       language, old_language, main_doc
FROM eventlog
ORDER BY id DESC
LIMIT 1
`

type GetLastEventRow struct {
	ID          int64
	Event       string
	UUID        uuid.UUID
	Timestamp   pgtype.Timestamptz
	Updater     pgtype.Text
	Type        pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
}

func (q *Queries) GetLastEvent(ctx context.Context) (GetLastEventRow, error) {
	row := q.db.QueryRow(ctx, getLastEvent)
	var i GetLastEventRow
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.UUID,
		&i.Timestamp,
		&i.Updater,
		&i.Type,
		&i.Version,
		&i.Status,
		&i.StatusID,
		&i.Acl,
		&i.Language,
		&i.OldLanguage,
		&i.MainDoc,
	)
	return i, err
}

const getLastEventID = `-- name: GetLastEventID :one
SELECT id FROM eventlog
ORDER BY id DESC LIMIT 1
`

func (q *Queries) GetLastEventID(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLastEventID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getMetaDocVersion = `-- name: GetMetaDocVersion :one
SELECT current_version FROM document
WHERE main_doc = $1
`

func (q *Queries) GetMetaDocVersion(ctx context.Context, argUuid pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getMetaDocVersion, argUuid)
	var current_version int64
	err := row.Scan(&current_version)
	return current_version, err
}

const getMetricKind = `-- name: GetMetricKind :one
SELECT name, aggregation
FROM metric_kind 
WHERE name = $1
`

func (q *Queries) GetMetricKind(ctx context.Context, name string) (MetricKind, error) {
	row := q.db.QueryRow(ctx, getMetricKind, name)
	var i MetricKind
	err := row.Scan(&i.Name, &i.Aggregation)
	return i, err
}

const getMetricKinds = `-- name: GetMetricKinds :many
SELECT name, aggregation
FROM metric_kind 
ORDER BY name
`

func (q *Queries) GetMetricKinds(ctx context.Context) ([]MetricKind, error) {
	rows, err := q.db.Query(ctx, getMetricKinds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricKind
	for rows.Next() {
		var i MetricKind
		if err := rows.Scan(&i.Name, &i.Aggregation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextReportDueTime = `-- name: GetNextReportDueTime :one
SELECT MIN(next_execution)::timestamptz
FROM report
WHERE enabled
`

func (q *Queries) GetNextReportDueTime(ctx context.Context) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getNextReportDueTime)
	var column_1 pgtype.Timestamptz
	err := row.Scan(&column_1)
	return column_1, err
}

const getPlanningAssignment = `-- name: GetPlanningAssignment :one
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
FROM planning_assignment
WHERE uuid = $1
`

func (q *Queries) GetPlanningAssignment(ctx context.Context, argUuid uuid.UUID) (PlanningAssignment, error) {
	row := q.db.QueryRow(ctx, getPlanningAssignment, argUuid)
	var i PlanningAssignment
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.PlanningItem,
		&i.Status,
		&i.Publish,
		&i.PublishSlot,
		&i.Starts,
		&i.Ends,
		&i.StartDate,
		&i.EndDate,
		&i.FullDay,
		&i.Public,
		&i.Kind,
		&i.Description,
	)
	return i, err
}

const getPlanningAssignments = `-- name: GetPlanningAssignments :many
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
FROM planning_assignment
WHERE planning_item = $1
`

func (q *Queries) GetPlanningAssignments(ctx context.Context, planningItem uuid.UUID) ([]PlanningAssignment, error) {
	rows, err := q.db.Query(ctx, getPlanningAssignments, planningItem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanningAssignment
	for rows.Next() {
		var i PlanningAssignment
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.PlanningItem,
			&i.Status,
			&i.Publish,
			&i.PublishSlot,
			&i.Starts,
			&i.Ends,
			&i.StartDate,
			&i.EndDate,
			&i.FullDay,
			&i.Public,
			&i.Kind,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanningItem = `-- name: GetPlanningItem :one
SELECT
        uuid, version, title, description, public, tentative,
        start_date, end_date, priority, event
FROM planning_item
WHERE uuid = $1
`

func (q *Queries) GetPlanningItem(ctx context.Context, argUuid uuid.UUID) (PlanningItem, error) {
	row := q.db.QueryRow(ctx, getPlanningItem, argUuid)
	var i PlanningItem
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Title,
		&i.Description,
		&i.Public,
		&i.Tentative,
		&i.StartDate,
		&i.EndDate,
		&i.Priority,
		&i.Event,
	)
	return i, err
}

const getReport = `-- name: GetReport :one
SELECT name, enabled, next_execution, spec
FROM report
WHERE name = $1
`

func (q *Queries) GetReport(ctx context.Context, name string) (Report, error) {
	row := q.db.QueryRow(ctx, getReport, name)
	var i Report
	err := row.Scan(
		&i.Name,
		&i.Enabled,
		&i.NextExecution,
		&i.Spec,
	)
	return i, err
}

const getSchema = `-- name: GetSchema :one
SELECT s.name, s.version, s.spec
FROM document_schema AS s
WHERE s.name = $1 AND s.version = $2
`

type GetSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) GetSchema(ctx context.Context, arg GetSchemaParams) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getSchema, arg.Name, arg.Version)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getSchemaVersions = `-- name: GetSchemaVersions :many
SELECT a.name, a.version
FROM active_schemas AS a
`

func (q *Queries) GetSchemaVersions(ctx context.Context) ([]ActiveSchema, error) {
	rows, err := q.db.Query(ctx, getSchemaVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveSchema
	for rows.Next() {
		var i ActiveSchema
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSigningKeys = `-- name: GetSigningKeys :many
SELECT kid, spec FROM signing_keys
`

func (q *Queries) GetSigningKeys(ctx context.Context) ([]SigningKey, error) {
	rows, err := q.db.Query(ctx, getSigningKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SigningKey
	for rows.Next() {
		var i SigningKey
		if err := rows.Scan(&i.Kid, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusRules = `-- name: GetStatusRules :many
SELECT name, description, access_rule, applies_to, for_types, expression
FROM status_rule
`

func (q *Queries) GetStatusRules(ctx context.Context) ([]StatusRule, error) {
	rows, err := q.db.Query(ctx, getStatusRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatusRule
	for rows.Next() {
		var i StatusRule
		if err := rows.Scan(
			&i.Name,
			&i.Description,
			&i.AccessRule,
			&i.AppliesTo,
			&i.ForTypes,
			&i.Expression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusVersions = `-- name: GetStatusVersions :many
SELECT id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id < $3::bigint)
ORDER BY id DESC
LIMIT $4
`

type GetStatusVersionsParams struct {
	UUID   uuid.UUID
	Name   string
	Before int64
	Count  int32
}

type GetStatusVersionsRow struct {
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatusVersions(ctx context.Context, arg GetStatusVersionsParams) ([]GetStatusVersionsRow, error) {
	rows, err := q.db.Query(ctx, getStatusVersions,
		arg.UUID,
		arg.Name,
		arg.Before,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusVersionsRow
	for rows.Next() {
		var i GetStatusVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
SELECT uuid, name, id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetStatusesParams struct {
	UUID    uuid.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

type GetStatusesRow struct {
	UUID       uuid.UUID
	Name       string
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]GetStatusesRow, error) {
	rows, err := q.db.Query(ctx, getStatuses,
		arg.UUID,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesRow
	for rows.Next() {
		var i GetStatusesRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersion = `-- name: GetVersion :one
SELECT created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetVersionRow struct {
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersion(ctx context.Context, arg GetVersionParams) (GetVersionRow, error) {
	row := q.db.QueryRow(ctx, getVersion, arg.UUID, arg.Version)
	var i GetVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.Archived,
	)
	return i, err
}

const getVersions = `-- name: GetVersions :many
SELECT version, created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND ($2::bigint = 0 OR version < $2::bigint)
ORDER BY version DESC
LIMIT $3
`

type GetVersionsParams struct {
	UUID   uuid.UUID
	Before int64
	Count  int32
}

type GetVersionsRow struct {
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersions(ctx context.Context, arg GetVersionsParams) ([]GetVersionsRow, error) {
	rows, err := q.db.Query(ctx, getVersions, arg.UUID, arg.Before, arg.Count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsRow
	for rows.Next() {
		var i GetVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const granteesWithPermission = `-- name: GranteesWithPermission :many
SELECT uri
FROM acl
WHERE uuid = $1
      AND $2::text = ANY(permissions)
`

type GranteesWithPermissionParams struct {
	UUID       uuid.UUID
	Permission string
}

func (q *Queries) GranteesWithPermission(ctx context.Context, arg GranteesWithPermissionParams) ([]string, error) {
	rows, err := q.db.Query(ctx, granteesWithPermission, arg.UUID, arg.Permission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uri string
		if err := rows.Scan(&uri); err != nil {
			return nil, err
		}
		items = append(items, uri)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertACLAuditEntry = `-- name: InsertACLAuditEntry :exec
INSERT INTO acl_audit(
       uuid, type, updated,
       updater_uri, state, language
)
SELECT
       $1::uuid, $2, $3::timestamptz,
       $4::text, json_agg(l), $5::text
FROM (
       SELECT uri, permissions
       FROM acl
       WHERE uuid = $1::uuid
) AS l
`

type InsertACLAuditEntryParams struct {
	UUID       uuid.UUID
	Type       pgtype.Text
	Updated    pgtype.Timestamptz
	UpdaterUri string
	Language   string
}

func (q *Queries) InsertACLAuditEntry(ctx context.Context, arg InsertACLAuditEntryParams) error {
	_, err := q.db.Exec(ctx, insertACLAuditEntry,
		arg.UUID,
		arg.Type,
		arg.Updated,
		arg.UpdaterUri,
		arg.Language,
	)
	return err
}

const insertDeleteRecord = `-- name: InsertDeleteRecord :one
INSERT INTO delete_record(
       uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language
) VALUES(
       $1, $2, $3, $4, $5, $6, $7,
       $8, $9
) RETURNING id
`

type InsertDeleteRecordParams struct {
	UUID       uuid.UUID
	URI        string
	Type       string
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	MainDoc    pgtype.UUID
	Language   pgtype.Text
}

func (q *Queries) InsertDeleteRecord(ctx context.Context, arg InsertDeleteRecordParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertDeleteRecord,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MainDoc,
		arg.Language,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDocumentLock = `-- name: InsertDocumentLock :exec
INSERT INTO document_lock(
  uuid, token, created, expires, uri, app, comment
) VALUES(
  $1, $2, $3, $4, $5, $6, $7
)
`

type InsertDocumentLockParams struct {
	UUID    uuid.UUID
	Token   string
	Created pgtype.Timestamptz
	Expires pgtype.Timestamptz
	URI     pgtype.Text
	App     pgtype.Text
	Comment pgtype.Text
}

func (q *Queries) InsertDocumentLock(ctx context.Context, arg InsertDocumentLockParams) error {
	_, err := q.db.Exec(ctx, insertDocumentLock,
		arg.UUID,
		arg.Token,
		arg.Created,
		arg.Expires,
		arg.URI,
		arg.App,
		arg.Comment,
	)
	return err
}

const insertDocumentStatus = `-- name: InsertDocumentStatus :exec
INSERT INTO document_status(
       uuid, name, id, version, created,
       creator_uri, meta, meta_doc_version
) VALUES (
       $1, $2, $3, $4, $5,
       $6, $7, $8::bigint
)
`

type InsertDocumentStatusParams struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           []byte
	MetaDocVersion int64
}

func (q *Queries) InsertDocumentStatus(ctx context.Context, arg InsertDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, insertDocumentStatus,
		arg.UUID,
		arg.Name,
		arg.ID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MetaDocVersion,
	)
	return err
}

const insertIntoEventLog = `-- name: InsertIntoEventLog :one
INSERT INTO eventlog(
       event, uuid, type, timestamp, updater, version, status, status_id, acl,
       language, old_language, main_doc
) VALUES (
       $1, $2, $3, $4, $5, $6, $7, $8, $9,
       $10, $11, $12
) RETURNING id
`

type InsertIntoEventLogParams struct {
	Event       string
	UUID        uuid.UUID
	Type        pgtype.Text
	Timestamp   pgtype.Timestamptz
	Updater     pgtype.Text
	Version     pgtype.Int8
	Status      pgtype.Text
	StatusID    pgtype.Int8
	Acl         []byte
	Language    pgtype.Text
	OldLanguage pgtype.Text
	MainDoc     pgtype.UUID
}

func (q *Queries) InsertIntoEventLog(ctx context.Context, arg InsertIntoEventLogParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertIntoEventLog,
		arg.Event,
		arg.UUID,
		arg.Type,
		arg.Timestamp,
		arg.Updater,
		arg.Version,
		arg.Status,
		arg.StatusID,
		arg.Acl,
		arg.Language,
		arg.OldLanguage,
		arg.MainDoc,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertJobLock = `-- name: InsertJobLock :one
INSERT INTO job_lock(name, holder, touched, iteration)
VALUES ($1, $2, now(), 1)
RETURNING iteration
`

type InsertJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) InsertJobLock(ctx context.Context, arg InsertJobLockParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertJobLock, arg.Name, arg.Holder)
	var iteration int64
	err := row.Scan(&iteration)
	return iteration, err
}

const insertSigningKey = `-- name: InsertSigningKey :exec
INSERT INTO signing_keys(kid, spec) VALUES($1, $2)
`

type InsertSigningKeyParams struct {
	Kid  string
	Spec []byte
}

func (q *Queries) InsertSigningKey(ctx context.Context, arg InsertSigningKeyParams) error {
	_, err := q.db.Exec(ctx, insertSigningKey, arg.Kid, arg.Spec)
	return err
}

const listReports = `-- name: ListReports :many
SELECT name, spec
FROM report
ORDER BY name
`

type ListReportsRow struct {
	Name string
	Spec []byte
}

func (q *Queries) ListReports(ctx context.Context) ([]ListReportsRow, error) {
	rows, err := q.db.Query(ctx, listReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReportsRow
	for rows.Next() {
		var i ListReportsRow
		if err := rows.Scan(&i.Name, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const pingJobLock = `-- name: PingJobLock :execrows
UPDATE job_lock
SET touched = now(),
    iteration = iteration + 1
WHERE name = $1
      AND holder = $2
      AND iteration = $3
`

type PingJobLockParams struct {
	Name      string
	Holder    string
	Iteration int64
}

func (q *Queries) PingJobLock(ctx context.Context, arg PingJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, pingJobLock, arg.Name, arg.Holder, arg.Iteration)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const registerMetaType = `-- name: RegisterMetaType :exec
INSERT INTO meta_type(
       meta_type, exclusive_for_meta
) VALUES (
       $1, $2
) ON CONFLICT (meta_type) DO UPDATE SET
  exclusive_for_meta = $2
`

type RegisterMetaTypeParams struct {
	MetaType         string
	ExclusiveForMeta bool
}

func (q *Queries) RegisterMetaType(ctx context.Context, arg RegisterMetaTypeParams) error {
	_, err := q.db.Exec(ctx, registerMetaType, arg.MetaType, arg.ExclusiveForMeta)
	return err
}

const registerMetaTypeUse = `-- name: RegisterMetaTypeUse :exec
INSERT INTO meta_type_use(
       main_type, meta_type
) VALUES (
       $1, $2
)
`

type RegisterMetaTypeUseParams struct {
	MainType string
	MetaType string
}

func (q *Queries) RegisterMetaTypeUse(ctx context.Context, arg RegisterMetaTypeUseParams) error {
	_, err := q.db.Exec(ctx, registerMetaTypeUse, arg.MainType, arg.MetaType)
	return err
}

const registerMetricKind = `-- name: RegisterMetricKind :exec
INSERT INTO metric_kind(name, aggregation)
VALUES ($1, $2)
`

type RegisterMetricKindParams struct {
	Name        string
	Aggregation int16
}

func (q *Queries) RegisterMetricKind(ctx context.Context, arg RegisterMetricKindParams) error {
	_, err := q.db.Exec(ctx, registerMetricKind, arg.Name, arg.Aggregation)
	return err
}

const registerOrIncrementMetric = `-- name: RegisterOrIncrementMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = metric.value + $4
`

type RegisterOrIncrementMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrIncrementMetric(ctx context.Context, arg RegisterOrIncrementMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrIncrementMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerOrReplaceMetric = `-- name: RegisterOrReplaceMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = $4
`

type RegisterOrReplaceMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrReplaceMetric(ctx context.Context, arg RegisterOrReplaceMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrReplaceMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerSchema = `-- name: RegisterSchema :exec
INSERT INTO document_schema(name, version, spec)
VALUES ($1, $2, $3)
`

type RegisterSchemaParams struct {
	Name    string
	Version string
	Spec    []byte
}

func (q *Queries) RegisterSchema(ctx context.Context, arg RegisterSchemaParams) error {
	_, err := q.db.Exec(ctx, registerSchema, arg.Name, arg.Version, arg.Spec)
	return err
}

const releaseJobLock = `-- name: ReleaseJobLock :execrows
DELETE FROM job_lock
WHERE name = $1
      AND holder = $2
`

type ReleaseJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) ReleaseJobLock(ctx context.Context, arg ReleaseJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseJobLock, arg.Name, arg.Holder)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setDocumentStatusAsArchived = `-- name: SetDocumentStatusAsArchived :exec
UPDATE document_status
SET archived = true, signature = $1::text
WHERE uuid = $2 AND id = $3
`

type SetDocumentStatusAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	ID        int64
}

func (q *Queries) SetDocumentStatusAsArchived(ctx context.Context, arg SetDocumentStatusAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentStatusAsArchived, arg.Signature, arg.UUID, arg.ID)
	return err
}

const setDocumentVersionAsArchived = `-- name: SetDocumentVersionAsArchived :exec
UPDATE document_version
SET archived = true, signature = $1::text
WHERE uuid = $2 AND version = $3
`

type SetDocumentVersionAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	Version   int64
}

func (q *Queries) SetDocumentVersionAsArchived(ctx context.Context, arg SetDocumentVersionAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentVersionAsArchived, arg.Signature, arg.UUID, arg.Version)
	return err
}

const setNextReportExecution = `-- name: SetNextReportExecution :exec
UPDATE report
SET next_execution = $1
WHERE name = $2
`

type SetNextReportExecutionParams struct {
	NextExecution pgtype.Timestamptz
	Name          string
}

func (q *Queries) SetNextReportExecution(ctx context.Context, arg SetNextReportExecutionParams) error {
	_, err := q.db.Exec(ctx, setNextReportExecution, arg.NextExecution, arg.Name)
	return err
}

const setPlanningAssignee = `-- name: SetPlanningAssignee :exec
INSERT INTO planning_assignee(
       assignment, assignee, version, role
) VALUES (
       $1, $2, $3, $4
)
ON CONFLICT ON CONSTRAINT planning_assignee_pkey DO UPDATE
SET version = $3, role = $4
`

type SetPlanningAssigneeParams struct {
	Assignment uuid.UUID
	Assignee   uuid.UUID
	Version    int64
	Role       string
}

func (q *Queries) SetPlanningAssignee(ctx context.Context, arg SetPlanningAssigneeParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignee,
		arg.Assignment,
		arg.Assignee,
		arg.Version,
		arg.Role,
	)
	return err
}

const setPlanningAssignment = `-- name: SetPlanningAssignment :exec
INSERT INTO planning_assignment(
       uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
) VALUES (
       $1, $2, $3, $4, $5, $6,
       $7, $8, $9, $10, $11, $12, $13,
       $14
)
ON CONFLICT ON CONSTRAINT planning_assignment_pkey DO UPDATE
SET
   version = $2, planning_item = $3, status = $4,
   publish = $5, publish_slot = $6, starts = $7,
   ends = $8, start_date = $9, end_date = $10,
   full_day = $11, public = $12, kind = $13,
   description = $14
`

type SetPlanningAssignmentParams struct {
	UUID         uuid.UUID
	Version      int64
	PlanningItem uuid.UUID
	Status       pgtype.Text
	Publish      pgtype.Timestamptz
	PublishSlot  pgtype.Int2
	Starts       pgtype.Timestamptz
	Ends         pgtype.Timestamptz
	StartDate    pgtype.Date
	EndDate      pgtype.Date
	FullDay      bool
	Public       bool
	Kind         []string
	Description  string
}

func (q *Queries) SetPlanningAssignment(ctx context.Context, arg SetPlanningAssignmentParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignment,
		arg.UUID,
		arg.Version,
		arg.PlanningItem,
		arg.Status,
		arg.Publish,
		arg.PublishSlot,
		arg.Starts,
		arg.Ends,
		arg.StartDate,
		arg.EndDate,
		arg.FullDay,
		arg.Public,
		arg.Kind,
		arg.Description,
	)
	return err
}

const setPlanningItem = `-- name: SetPlanningItem :exec
INSERT INTO planning_item(
        uuid, version, title, description, public, tentative,
        start_date, end_date, priority, event
) VALUES (
        $1, $2, $3, $4, $5, $6,
        $7, $8, $9, $10
)
ON CONFLICT ON CONSTRAINT planning_item_pkey DO UPDATE
SET
   version = $2, title = $3, description = $4,
   public = $5, tentative = $6, start_date = $7,
   end_date = $8, priority = $9, event = $10
`

type SetPlanningItemParams struct {
	UUID        uuid.UUID
	Version     int64
	Title       string
	Description string
	Public      bool
	Tentative   bool
	StartDate   pgtype.Date
	EndDate     pgtype.Date
	Priority    pgtype.Int2
	Event       pgtype.UUID
}

func (q *Queries) SetPlanningItem(ctx context.Context, arg SetPlanningItemParams) error {
	_, err := q.db.Exec(ctx, setPlanningItem,
		arg.UUID,
		arg.Version,
		arg.Title,
		arg.Description,
		arg.Public,
		arg.Tentative,
		arg.StartDate,
		arg.EndDate,
		arg.Priority,
		arg.Event,
	)
	return err
}

const setPlanningItemDeliverable = `-- name: SetPlanningItemDeliverable :exec
INSERT INTO planning_deliverable(
       assignment, document, version
) VALUES(
       $1, $2, $3
)
ON CONFLICT ON CONSTRAINT planning_deliverable_pkey DO UPDATE
SET
   version = $3
`

type SetPlanningItemDeliverableParams struct {
	Assignment uuid.UUID
	Document   uuid.UUID
	Version    int64
}

func (q *Queries) SetPlanningItemDeliverable(ctx context.Context, arg SetPlanningItemDeliverableParams) error {
	_, err := q.db.Exec(ctx, setPlanningItemDeliverable, arg.Assignment, arg.Document, arg.Version)
	return err
}

const stealJobLock = `-- name: StealJobLock :execrows
UPDATE job_lock
SET holder = $1,
    touched = now(),
    iteration = iteration + 1
WHERE name = $2
      AND holder = $3
      AND iteration = $4
`

type StealJobLockParams struct {
	NewHolder      string
	Name           string
	PreviousHolder string
	Iteration      int64
}

func (q *Queries) StealJobLock(ctx context.Context, arg StealJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, stealJobLock,
		arg.NewHolder,
		arg.Name,
		arg.PreviousHolder,
		arg.Iteration,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateDocumentLock = `-- name: UpdateDocumentLock :exec
UPDATE document_lock
SET expires = $1
WHERE uuid = $2
`

type UpdateDocumentLockParams struct {
	Expires pgtype.Timestamptz
	UUID    uuid.UUID
}

func (q *Queries) UpdateDocumentLock(ctx context.Context, arg UpdateDocumentLockParams) error {
	_, err := q.db.Exec(ctx, updateDocumentLock, arg.Expires, arg.UUID)
	return err
}

const updateEventsinkPosition = `-- name: UpdateEventsinkPosition :exec
UPDATE eventsink SET position = $1 WHERE name = $2
`

type UpdateEventsinkPositionParams struct {
	Position int64
	Name     string
}

func (q *Queries) UpdateEventsinkPosition(ctx context.Context, arg UpdateEventsinkPositionParams) error {
	_, err := q.db.Exec(ctx, updateEventsinkPosition, arg.Position, arg.Name)
	return err
}

const updateReport = `-- name: UpdateReport :exec
INSERT INTO report(
       name, enabled, next_execution, spec
) VALUES (
       $1, $2, $3, $4
) ON CONFLICT (name) DO UPDATE SET
  enabled = $2,
  next_execution = $3,
  spec = $4
`

type UpdateReportParams struct {
	Name          string
	Enabled       bool
	NextExecution pgtype.Timestamptz
	Spec          []byte
}

func (q *Queries) UpdateReport(ctx context.Context, arg UpdateReportParams) error {
	_, err := q.db.Exec(ctx, updateReport,
		arg.Name,
		arg.Enabled,
		arg.NextExecution,
		arg.Spec,
	)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
INSERT INTO status(name, disabled)
VALUES($1, $2)
ON CONFLICT(name) DO UPDATE SET
   disabled = $2
`

type UpdateStatusParams struct {
	Name     string
	Disabled bool
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Name, arg.Disabled)
	return err
}

const updateStatusRule = `-- name: UpdateStatusRule :exec
INSERT INTO status_rule(
       name, description, access_rule, applies_to, for_types, expression
) VALUES(
       $1, $2, $3, $4, $5, $6
) ON CONFLICT(name)
  DO UPDATE SET
     description = $2, access_rule = $3,
     applies_to = $4, for_types = $5, expression = $6
`

type UpdateStatusRuleParams struct {
	Name        string
	Description string
	AccessRule  bool
	AppliesTo   []string
	ForTypes    []string
	Expression  string
}

func (q *Queries) UpdateStatusRule(ctx context.Context, arg UpdateStatusRuleParams) error {
	_, err := q.db.Exec(ctx, updateStatusRule,
		arg.Name,
		arg.Description,
		arg.AccessRule,
		arg.AppliesTo,
		arg.ForTypes,
		arg.Expression,
	)
	return err
}

const upsertDocument = `-- name: UpsertDocument :exec
INSERT INTO document(
       uuid, uri, type,
       created, creator_uri, updated, updater_uri, current_version,
       main_doc, language
) VALUES (
       $1, $2, $3,
       $4, $5, $4, $5, $6,
       $7, $8
) ON CONFLICT (uuid) DO UPDATE
     SET uri = $2,
         updated = $4,
         updater_uri = $5,
         current_version = $6,
         language = $8
`

type UpsertDocumentParams struct {
	UUID       uuid.UUID
	URI        string
	Type       string
	Created    pgtype.Timestamptz
	CreatorUri string
	Version    int64
	MainDoc    pgtype.UUID
	Language   pgtype.Text
}

func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Version,
		arg.MainDoc,
		arg.Language,
	)
	return err
}
