// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireTXLock = `-- name: AcquireTXLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireTXLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, acquireTXLock, id)
	return err
}

const activateSchema = `-- name: ActivateSchema :exec
INSERT INTO active_schemas(name, version)
VALUES ($1, $2)
       ON CONFLICT(name) DO UPDATE SET
          version = $2
`

type ActivateSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) ActivateSchema(ctx context.Context, arg ActivateSchemaParams) error {
	_, err := q.db.Exec(ctx, activateSchema, arg.Name, arg.Version)
	return err
}

const addAttachedObject = `-- name: AddAttachedObject :exec
INSERT INTO attached_object(
       document, name, version, object_version, attached_at,
       created_by, created_at, meta
) VALUES (
       $1, $2, $3, $4, $5,
       $6, $7, $8
)
`

type AddAttachedObjectParams struct {
	Document      uuid.UUID
	Name          string
	Version       int64
	ObjectVersion string
	AttachedAt    int64
	CreatedBy     string
	CreatedAt     pgtype.Timestamptz
	Meta          AssetMetadata
}

func (q *Queries) AddAttachedObject(ctx context.Context, arg AddAttachedObjectParams) error {
	_, err := q.db.Exec(ctx, addAttachedObject,
		arg.Document,
		arg.Name,
		arg.Version,
		arg.ObjectVersion,
		arg.AttachedAt,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.Meta,
	)
	return err
}

const addEventToOutbox = `-- name: AddEventToOutbox :one
INSERT INTO event_outbox_item(event)
VALUES($1)
RETURNING id
`

func (q *Queries) AddEventToOutbox(ctx context.Context, event OutboxEvent) (int64, error) {
	row := q.db.QueryRow(ctx, addEventToOutbox, event)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const bulkCheckPermissions = `-- name: BulkCheckPermissions :many
SELECT d.uuid
FROM document AS d
     INNER JOIN acl
          ON (acl.uuid = d.uuid OR acl.uuid = d.main_doc)
          AND acl.uri = ANY($1::text[])
          AND $2::text[] && permissions
WHERE d.uuid = ANY($3::uuid[])
`

type BulkCheckPermissionsParams struct {
	URI         []string
	Permissions []string
	Uuids       []uuid.UUID
}

func (q *Queries) BulkCheckPermissions(ctx context.Context, arg BulkCheckPermissionsParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, bulkCheckPermissions, arg.URI, arg.Permissions, arg.Uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var uuid uuid.UUID
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetAttachments = `-- name: BulkGetAttachments :many
SELECT document, name, version FROM attached_object_current
WHERE document = ANY($1::uuid[])
      AND deleted = false
`

type BulkGetAttachmentsRow struct {
	Document uuid.UUID
	Name     string
	Version  int64
}

func (q *Queries) BulkGetAttachments(ctx context.Context, documents []uuid.UUID) ([]BulkGetAttachmentsRow, error) {
	rows, err := q.db.Query(ctx, bulkGetAttachments, documents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkGetAttachmentsRow
	for rows.Next() {
		var i BulkGetAttachmentsRow
		if err := rows.Scan(&i.Document, &i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetDocumentACL = `-- name: BulkGetDocumentACL :many
SELECT uuid, uri, permissions
FROM acl
WHERE uuid = ANY($1::uuid[])
`

func (q *Queries) BulkGetDocumentACL(ctx context.Context, uuids []uuid.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, bulkGetDocumentACL, uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.UUID, &i.URI, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetDocumentData = `-- name: BulkGetDocumentData :many
WITH refs AS (
     SELECT unnest($1::uuid[]) AS uuid,
            unnest($2::bigint[]) AS version
)
SELECT v.uuid, v.version, v.document_data
FROM refs AS r
     INNER JOIN document as d ON d.uuid = r.uuid
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid AND (
                  (r.version = 0 AND v.version = d.current_version)
                  OR v.version = r.version
           )
`

type BulkGetDocumentDataParams struct {
	Uuids    []uuid.UUID
	Versions []int64
}

type BulkGetDocumentDataRow struct {
	UUID         uuid.UUID
	Version      int64
	DocumentData []byte
}

func (q *Queries) BulkGetDocumentData(ctx context.Context, arg BulkGetDocumentDataParams) ([]BulkGetDocumentDataRow, error) {
	rows, err := q.db.Query(ctx, bulkGetDocumentData, arg.Uuids, arg.Versions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkGetDocumentDataRow
	for rows.Next() {
		var i BulkGetDocumentDataRow
		if err := rows.Scan(&i.UUID, &i.Version, &i.DocumentData); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetDocumentInfo = `-- name: BulkGetDocumentInfo :many
SELECT
        d.uuid, d.uri, d.created, d.creator_uri, d.updated, d.updater_uri, d.current_version,
        d.system_state, d.main_doc, d.nonce, l.uuid as lock_uuid, l.uri as lock_uri,
        l.created as lock_created, l.expires as lock_expires, l.app as lock_app,
        l.comment as lock_comment, l.token as lock_token,
        ws.step as workflow_state, ws.checkpoint as workflow_checkpoint
FROM document as d
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $1
LEFT JOIN workflow_state AS ws ON ws.uuid = d.uuid
WHERE d.uuid = ANY($2::uuid[])
`

type BulkGetDocumentInfoParams struct {
	Now   pgtype.Timestamptz
	Uuids []uuid.UUID
}

type BulkGetDocumentInfoRow struct {
	UUID               uuid.UUID
	URI                string
	Created            pgtype.Timestamptz
	CreatorUri         string
	Updated            pgtype.Timestamptz
	UpdaterUri         string
	CurrentVersion     int64
	SystemState        pgtype.Text
	MainDoc            pgtype.UUID
	Nonce              uuid.UUID
	LockUuid           pgtype.UUID
	LockUri            pgtype.Text
	LockCreated        pgtype.Timestamptz
	LockExpires        pgtype.Timestamptz
	LockApp            pgtype.Text
	LockComment        pgtype.Text
	LockToken          pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
}

func (q *Queries) BulkGetDocumentInfo(ctx context.Context, arg BulkGetDocumentInfoParams) ([]BulkGetDocumentInfoRow, error) {
	rows, err := q.db.Query(ctx, bulkGetDocumentInfo, arg.Now, arg.Uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkGetDocumentInfoRow
	for rows.Next() {
		var i BulkGetDocumentInfoRow
		if err := rows.Scan(
			&i.UUID,
			&i.URI,
			&i.Created,
			&i.CreatorUri,
			&i.Updated,
			&i.UpdaterUri,
			&i.CurrentVersion,
			&i.SystemState,
			&i.MainDoc,
			&i.Nonce,
			&i.LockUuid,
			&i.LockUri,
			&i.LockCreated,
			&i.LockExpires,
			&i.LockApp,
			&i.LockComment,
			&i.LockToken,
			&i.WorkflowState,
			&i.WorkflowCheckpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bulkGetFullDocumentHeads = `-- name: BulkGetFullDocumentHeads :many
SELECT s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
       s.archived, s.signature, s.meta_doc_version, h.language
FROM status_heads AS h
     INNER JOIN document_status AS s ON
           s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = ANY($1::uuid[])
`

type BulkGetFullDocumentHeadsRow struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	Archived       bool
	Signature      pgtype.Text
	MetaDocVersion pgtype.Int8
	Language       pgtype.Text
}

func (q *Queries) BulkGetFullDocumentHeads(ctx context.Context, uuids []uuid.UUID) ([]BulkGetFullDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, bulkGetFullDocumentHeads, uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BulkGetFullDocumentHeadsRow
	for rows.Next() {
		var i BulkGetFullDocumentHeadsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
			&i.Signature,
			&i.MetaDocVersion,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeAttachedObjectVersion = `-- name: ChangeAttachedObjectVersion :exec
UPDATE attached_object SET object_version = $1
WHERE document = $2
      AND name = $3
      AND version = $4
`

type ChangeAttachedObjectVersionParams struct {
	ObjectVersion string
	Document      uuid.UUID
	Name          string
	Version       int64
}

func (q *Queries) ChangeAttachedObjectVersion(ctx context.Context, arg ChangeAttachedObjectVersionParams) error {
	_, err := q.db.Exec(ctx, changeAttachedObjectVersion,
		arg.ObjectVersion,
		arg.Document,
		arg.Name,
		arg.Version,
	)
	return err
}

const changeWorkflowState = `-- name: ChangeWorkflowState :exec
INSERT INTO workflow_state(
       uuid, type, language, updated, updater_uri, step, checkpoint,
       status_name, status_id, document_version
) VALUES (
       $1, $2, $3, $4, $5, $6,
       $7, $8, $9, $10
) ON CONFLICT(uuid) DO UPDATE SET
  type = excluded.type,
  language = excluded.language,
  updated = excluded.updated,
  updater_uri = excluded.updater_uri,
  step = excluded.step,
  checkpoint = excluded.checkpoint,
  status_name = excluded.status_name,
  status_id = excluded.status_id,
  document_version = excluded.document_version
`

type ChangeWorkflowStateParams struct {
	UUID            uuid.UUID
	Type            string
	Language        string
	Updated         pgtype.Timestamptz
	UpdaterUri      string
	Step            string
	Checkpoint      string
	StatusName      pgtype.Text
	StatusID        pgtype.Int8
	DocumentVersion int64
}

func (q *Queries) ChangeWorkflowState(ctx context.Context, arg ChangeWorkflowStateParams) error {
	_, err := q.db.Exec(ctx, changeWorkflowState,
		arg.UUID,
		arg.Type,
		arg.Language,
		arg.Updated,
		arg.UpdaterUri,
		arg.Step,
		arg.Checkpoint,
		arg.StatusName,
		arg.StatusID,
		arg.DocumentVersion,
	)
	return err
}

const checkForPendingPurge = `-- name: CheckForPendingPurge :one
SELECT EXISTS (
       SELECT 1 FROM purge_request
       WHERE delete_record_id = $1
       AND finished IS NULL
)
`

func (q *Queries) CheckForPendingPurge(ctx context.Context, deleteRecordID int64) (bool, error) {
	row := q.db.QueryRow(ctx, checkForPendingPurge, deleteRecordID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMetaDocumentType = `-- name: CheckMetaDocumentType :one
SELECT coalesce(meta_type, ''), NOT d.main_doc IS NULL as is_meta_doc
FROM document AS d
     LEFT JOIN meta_type_use AS m ON m.main_type = d.type
WHERE d.uuid = $1
`

type CheckMetaDocumentTypeRow struct {
	MetaType  string
	IsMetaDoc pgtype.Bool
}

func (q *Queries) CheckMetaDocumentType(ctx context.Context, argUuid uuid.UUID) (CheckMetaDocumentTypeRow, error) {
	row := q.db.QueryRow(ctx, checkMetaDocumentType, argUuid)
	var i CheckMetaDocumentTypeRow
	err := row.Scan(&i.MetaType, &i.IsMetaDoc)
	return i, err
}

const checkPermissions = `-- name: CheckPermissions :one
SELECT (acl.uri IS NOT NULL) = true AS has_access, d.system_state
FROM document AS d
     LEFT JOIN acl
          ON (acl.uuid = d.uuid OR acl.uuid = d.main_doc)
          AND acl.uri = ANY($1::text[])
          AND $2::text[] && permissions
WHERE d.uuid = $3
`

type CheckPermissionsParams struct {
	URI         []string
	Permissions []string
	UUID        uuid.UUID
}

type CheckPermissionsRow struct {
	HasAccess   bool
	SystemState pgtype.Text
}

func (q *Queries) CheckPermissions(ctx context.Context, arg CheckPermissionsParams) (CheckPermissionsRow, error) {
	row := q.db.QueryRow(ctx, checkPermissions, arg.URI, arg.Permissions, arg.UUID)
	var i CheckPermissionsRow
	err := row.Scan(&i.HasAccess, &i.SystemState)
	return i, err
}

const cleanUpAssignees = `-- name: CleanUpAssignees :exec
DELETE FROM planning_assignee
WHERE assignment = $1 AND version != $2
`

type CleanUpAssigneesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpAssignees(ctx context.Context, arg CleanUpAssigneesParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignees, arg.Assignment, arg.Version)
	return err
}

const cleanUpAssignments = `-- name: CleanUpAssignments :exec
DELETE FROM planning_assignment
WHERE planning_item = $1 AND version != $2
`

type CleanUpAssignmentsParams struct {
	PlanningItem uuid.UUID
	Version      int64
}

func (q *Queries) CleanUpAssignments(ctx context.Context, arg CleanUpAssignmentsParams) error {
	_, err := q.db.Exec(ctx, cleanUpAssignments, arg.PlanningItem, arg.Version)
	return err
}

const cleanUpDeliverables = `-- name: CleanUpDeliverables :exec
DELETE FROM planning_deliverable
WHERE assignment = $1 AND version != $2
`

type CleanUpDeliverablesParams struct {
	Assignment uuid.UUID
	Version    int64
}

func (q *Queries) CleanUpDeliverables(ctx context.Context, arg CleanUpDeliverablesParams) error {
	_, err := q.db.Exec(ctx, cleanUpDeliverables, arg.Assignment, arg.Version)
	return err
}

const clearSystemState = `-- name: ClearSystemState :exec
UPDATE document SET system_state = NULL
WHERE uuid = $1 AND NOT system_state IS NULL
`

func (q *Queries) ClearSystemState(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearSystemState, argUuid)
	return err
}

const configureEventsink = `-- name: ConfigureEventsink :exec
INSERT INTO eventsink(name, configuration) VALUES($1, $2)
ON CONFLICT (name) DO UPDATE SET
   configuration = $2
`

type ConfigureEventsinkParams struct {
	Name   string
	Config []byte
}

func (q *Queries) ConfigureEventsink(ctx context.Context, arg ConfigureEventsinkParams) error {
	_, err := q.db.Exec(ctx, configureEventsink, arg.Name, arg.Config)
	return err
}

const createDocumentVersion = `-- name: CreateDocumentVersion :exec
INSERT INTO document_version(
       uuid, version,
       created, creator_uri, meta, document_data, archived, language,
       time, labels
) VALUES (
       $1, $2,
       $3, $4, $5, $6, false, $7,
       $8, $9
)
`

type CreateDocumentVersionParams struct {
	UUID         uuid.UUID
	Version      int64
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Language     pgtype.Text
	Time         pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	Labels       []string
}

func (q *Queries) CreateDocumentVersion(ctx context.Context, arg CreateDocumentVersionParams) error {
	_, err := q.db.Exec(ctx, createDocumentVersion,
		arg.UUID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.DocumentData,
		arg.Language,
		arg.Time,
		arg.Labels,
	)
	return err
}

const createStatusHead = `-- name: CreateStatusHead :exec
INSERT INTO status_heads(
       uuid, name, type, version, current_id,
       updated, updater_uri, language, system_state
) VALUES (
       $1, $2, $3::text, $4::bigint, $5::bigint,
       $6, $7, $8::text, $9
)
ON CONFLICT (uuid, name) DO UPDATE
   SET updated = $6,
       updater_uri = $7,
       current_id = $5::bigint,
       version = $4::bigint,
       language = $8::text
`

type CreateStatusHeadParams struct {
	UUID        uuid.UUID
	Name        string
	Type        string
	Version     int64
	ID          int64
	Created     pgtype.Timestamptz
	CreatorUri  string
	Language    string
	SystemState pgtype.Text
}

func (q *Queries) CreateStatusHead(ctx context.Context, arg CreateStatusHeadParams) error {
	_, err := q.db.Exec(ctx, createStatusHead,
		arg.UUID,
		arg.Name,
		arg.Type,
		arg.Version,
		arg.ID,
		arg.Created,
		arg.CreatorUri,
		arg.Language,
		arg.SystemState,
	)
	return err
}

const createUpload = `-- name: CreateUpload :exec
INSERT INTO upload(id, created_at, created_by, meta)
VALUES ($1, $2, $3, $4)
`

type CreateUploadParams struct {
	ID        uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy string
	Meta      AssetMetadata
}

func (q *Queries) CreateUpload(ctx context.Context, arg CreateUploadParams) error {
	_, err := q.db.Exec(ctx, createUpload,
		arg.ID,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.Meta,
	)
	return err
}

const deactivateSchema = `-- name: DeactivateSchema :exec
DELETE FROM active_schemas
WHERE name = $1
`

func (q *Queries) DeactivateSchema(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deactivateSchema, name)
	return err
}

const deleteDocumentEntry = `-- name: DeleteDocumentEntry :exec
DELETE FROM document WHERE uuid = $1
`

func (q *Queries) DeleteDocumentEntry(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentEntry, argUuid)
	return err
}

const deleteDocumentLock = `-- name: DeleteDocumentLock :execrows
DELETE FROM document_lock
WHERE uuid = $1
  AND token = $2
`

type DeleteDocumentLockParams struct {
	UUID  uuid.UUID
	Token string
}

func (q *Queries) DeleteDocumentLock(ctx context.Context, arg DeleteDocumentLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteDocumentLock, arg.UUID, arg.Token)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteDocumentUnarchivedCounter = `-- name: DeleteDocumentUnarchivedCounter :exec
DELETE FROM document_archive_counter
WHERE uuid = $1
`

func (q *Queries) DeleteDocumentUnarchivedCounter(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentUnarchivedCounter, argUuid)
	return err
}

const deleteDocumentWorkflow = `-- name: DeleteDocumentWorkflow :execrows
DELETE FROM workflow WHERE type = $1
`

func (q *Queries) DeleteDocumentWorkflow(ctx context.Context, type_ string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteDocumentWorkflow, type_)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredDocumentLock = `-- name: DeleteExpiredDocumentLock :exec
DELETE FROM document_lock
WHERE uuid = ANY($1::uuid[])
  AND expires < $2
`

type DeleteExpiredDocumentLockParams struct {
	Uuids  []uuid.UUID
	Cutoff pgtype.Timestamptz
}

func (q *Queries) DeleteExpiredDocumentLock(ctx context.Context, arg DeleteExpiredDocumentLockParams) error {
	_, err := q.db.Exec(ctx, deleteExpiredDocumentLock, arg.Uuids, arg.Cutoff)
	return err
}

const deleteMetricKind = `-- name: DeleteMetricKind :exec
DELETE FROM metric_kind
WHERE name = $1
`

func (q *Queries) DeleteMetricKind(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteMetricKind, name)
	return err
}

const deleteOutboxEvent = `-- name: DeleteOutboxEvent :exec
DELETE FROM event_outbox_item WHERE id = $1
`

func (q *Queries) DeleteOutboxEvent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOutboxEvent, id)
	return err
}

const deletePlanningItem = `-- name: DeletePlanningItem :exec
DELETE FROM planning_item WHERE uuid = $1
`

func (q *Queries) DeletePlanningItem(ctx context.Context, argUuid uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlanningItem, argUuid)
	return err
}

const deleteStatusRule = `-- name: DeleteStatusRule :exec
DELETE FROM status_rule WHERE type = $1 AND name = $2
`

type DeleteStatusRuleParams struct {
	Type string
	Name string
}

func (q *Queries) DeleteStatusRule(ctx context.Context, arg DeleteStatusRuleParams) error {
	_, err := q.db.Exec(ctx, deleteStatusRule, arg.Type, arg.Name)
	return err
}

const dropACL = `-- name: DropACL :exec
DELETE FROM acl WHERE uuid = $1 AND uri = $2
`

type DropACLParams struct {
	UUID uuid.UUID
	URI  string
}

func (q *Queries) DropACL(ctx context.Context, arg DropACLParams) error {
	_, err := q.db.Exec(ctx, dropACL, arg.UUID, arg.URI)
	return err
}

const dropInvalidRestoreRequests = `-- name: DropInvalidRestoreRequests :exec
DELETE FROM restore_request AS rr
WHERE rr.finished IS NULL
AND rr.delete_record_id = ANY(
    SELECT dr.id FROM delete_record AS dr
    WHERE dr.id = rr.delete_record_id
    AND dr.purged IS NOT NULL
)
`

func (q *Queries) DropInvalidRestoreRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropInvalidRestoreRequests)
	return err
}

const dropMetaType = `-- name: DropMetaType :exec
DELETE FROM meta_type
WHERE meta_type = $1
`

func (q *Queries) DropMetaType(ctx context.Context, metaType string) error {
	_, err := q.db.Exec(ctx, dropMetaType, metaType)
	return err
}

const dropRedundantPurgeRequests = `-- name: DropRedundantPurgeRequests :exec
DELETE FROM purge_request AS pr
WHERE pr.finished IS NULL
AND pr.delete_record_id = ANY(
    SELECT dr.id FROM delete_record AS dr
    WHERE dr.id = pr.delete_record_id
    AND dr.purged IS NOT NULL
)
`

func (q *Queries) DropRedundantPurgeRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropRedundantPurgeRequests)
	return err
}

const finaliseDeleteRecord = `-- name: FinaliseDeleteRecord :exec
UPDATE delete_record SET finalised = $1
WHERE uuid = $2 AND id = $3
`

type FinaliseDeleteRecordParams struct {
	Finalised pgtype.Timestamptz
	UUID      uuid.UUID
	ID        int64
}

func (q *Queries) FinaliseDeleteRecord(ctx context.Context, arg FinaliseDeleteRecordParams) error {
	_, err := q.db.Exec(ctx, finaliseDeleteRecord, arg.Finalised, arg.UUID, arg.ID)
	return err
}

const finaliseDocumentDelete = `-- name: FinaliseDocumentDelete :execrows
DELETE FROM document
WHERE uuid = $1 AND system_state = 'deleting'
`

func (q *Queries) FinaliseDocumentDelete(ctx context.Context, argUuid uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, finaliseDocumentDelete, argUuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const finishPurgeRequest = `-- name: FinishPurgeRequest :exec
UPDATE purge_request
SET finished = $1
WHERE id = $2
`

type FinishPurgeRequestParams struct {
	Finished pgtype.Timestamptz
	ID       int64
}

func (q *Queries) FinishPurgeRequest(ctx context.Context, arg FinishPurgeRequestParams) error {
	_, err := q.db.Exec(ctx, finishPurgeRequest, arg.Finished, arg.ID)
	return err
}

const finishRestoreRequest = `-- name: FinishRestoreRequest :exec
UPDATE restore_request
SET finished = $1
WHERE id = $2
`

type FinishRestoreRequestParams struct {
	Finished pgtype.Timestamptz
	ID       int64
}

func (q *Queries) FinishRestoreRequest(ctx context.Context, arg FinishRestoreRequestParams) error {
	_, err := q.db.Exec(ctx, finishRestoreRequest, arg.Finished, arg.ID)
	return err
}

const getActiveSchema = `-- name: GetActiveSchema :one
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
WHERE a.name = $1
`

func (q *Queries) GetActiveSchema(ctx context.Context, name string) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getActiveSchema, name)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getActiveSchemas = `-- name: GetActiveSchemas :many
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
`

func (q *Queries) GetActiveSchemas(ctx context.Context) ([]DocumentSchema, error) {
	rows, err := q.db.Query(ctx, getActiveSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentSchema
	for rows.Next() {
		var i DocumentSchema
		if err := rows.Scan(&i.Name, &i.Version, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStatuses = `-- name: GetActiveStatuses :many
SELECT type, name
FROM status
WHERE disabled = false
      AND ($1::text IS NULL OR type = $1)
`

type GetActiveStatusesRow struct {
	Type string
	Name string
}

func (q *Queries) GetActiveStatuses(ctx context.Context, type_ pgtype.Text) ([]GetActiveStatusesRow, error) {
	rows, err := q.db.Query(ctx, getActiveStatuses, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveStatusesRow
	for rows.Next() {
		var i GetActiveStatusesRow
		if err := rows.Scan(&i.Type, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachedObject = `-- name: GetAttachedObject :one
SELECT
        o.document,
        o.name,
        o.version,
        o.object_version,
        o.attached_at,
        o.created_by,
        o.created_at,
        o.meta,
        c.deleted
FROM attached_object_current AS c
     INNER JOIN attached_object AS o ON
           o.document = c.document
           AND o.name = c.name
           AND o.version = c.version
WHERE c.document = $1
      AND c.name = $2
`

type GetAttachedObjectParams struct {
	Document uuid.UUID
	Name     string
}

type GetAttachedObjectRow struct {
	Document      uuid.UUID
	Name          string
	Version       int64
	ObjectVersion string
	AttachedAt    int64
	CreatedBy     string
	CreatedAt     pgtype.Timestamptz
	Meta          AssetMetadata
	Deleted       bool
}

func (q *Queries) GetAttachedObject(ctx context.Context, arg GetAttachedObjectParams) (GetAttachedObjectRow, error) {
	row := q.db.QueryRow(ctx, getAttachedObject, arg.Document, arg.Name)
	var i GetAttachedObjectRow
	err := row.Scan(
		&i.Document,
		&i.Name,
		&i.Version,
		&i.ObjectVersion,
		&i.AttachedAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Meta,
		&i.Deleted,
	)
	return i, err
}

const getAttachments = `-- name: GetAttachments :many
SELECT name, version FROM attached_object_current
WHERE document = $1
      AND deleted = false
`

type GetAttachmentsRow struct {
	Name    string
	Version int64
}

func (q *Queries) GetAttachments(ctx context.Context, document uuid.UUID) ([]GetAttachmentsRow, error) {
	rows, err := q.db.Query(ctx, getAttachments, document)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttachmentsRow
	for rows.Next() {
		var i GetAttachmentsRow
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttachmentsForDocuments = `-- name: GetAttachmentsForDocuments :many
SELECT
        o.document,
        o.name,
        o.version,
        o.meta
FROM attached_object_current AS c
     INNER JOIN attached_object AS o ON
           o.document = c.document
           AND o.name = c.name
           AND o.version = c.version
WHERE c.document = ANY($1::uuid[])
      AND c.name = $2
      AND c.deleted = false
`

type GetAttachmentsForDocumentsParams struct {
	Documents []uuid.UUID
	Name      string
}

type GetAttachmentsForDocumentsRow struct {
	Document uuid.UUID
	Name     string
	Version  int64
	Meta     AssetMetadata
}

func (q *Queries) GetAttachmentsForDocuments(ctx context.Context, arg GetAttachmentsForDocumentsParams) ([]GetAttachmentsForDocumentsRow, error) {
	rows, err := q.db.Query(ctx, getAttachmentsForDocuments, arg.Documents, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttachmentsForDocumentsRow
	for rows.Next() {
		var i GetAttachmentsForDocumentsRow
		if err := rows.Scan(
			&i.Document,
			&i.Name,
			&i.Version,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompactedEventlog = `-- name: GetCompactedEventlog :many
SELECT
        w.id, w.event, w.uuid, w.timestamp, w.type, w.version, w.status,
        w.status_id, w.acl, w.updater, w.language, w.old_language, w.main_doc,
        w.system_state, workflow_state, workflow_checkpoint, main_doc_type,
        extra, signature, nonce
FROM (
     SELECT DISTINCT ON (
            e.uuid,
            CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
            CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END
       ) id, event, uuid, timestamp, type, version, status, status_id, acl, updater, main_doc, language, old_language, system_state, workflow_state, workflow_checkpoint, main_doc_type, extra, signature, nonce FROM eventlog AS e
     WHERE e.id > $1 AND e.id <= $2
     AND ($3::text IS NULL OR e.type = $3)
     ORDER BY
           e.uuid,
           CASE WHEN e.event = 'delete_document' THEN null ELSE 0 END,
           CASE WHEN NOT e.old_language IS NULL THEN null ELSE 0 END,
           e.id DESC
     ) AS w
ORDER BY w.id ASC
LIMIT $5 OFFSET $4
`

type GetCompactedEventlogParams struct {
	After     int64
	Until     int64
	Type      pgtype.Text
	RowOffset int32
	RowLimit  pgtype.Int4
}

type GetCompactedEventlogRow struct {
	ID                 int64
	Event              string
	UUID               uuid.UUID
	Timestamp          pgtype.Timestamptz
	Type               pgtype.Text
	Version            pgtype.Int8
	Status             pgtype.Text
	StatusID           pgtype.Int8
	Acl                []byte
	Updater            pgtype.Text
	Language           pgtype.Text
	OldLanguage        pgtype.Text
	MainDoc            pgtype.UUID
	SystemState        pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
	MainDocType        pgtype.Text
	Extra              *EventlogExtra
	Signature          pgtype.Text
	Nonce              uuid.UUID
}

func (q *Queries) GetCompactedEventlog(ctx context.Context, arg GetCompactedEventlogParams) ([]GetCompactedEventlogRow, error) {
	rows, err := q.db.Query(ctx, getCompactedEventlog,
		arg.After,
		arg.Until,
		arg.Type,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompactedEventlogRow
	for rows.Next() {
		var i GetCompactedEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
			&i.SystemState,
			&i.WorkflowState,
			&i.WorkflowCheckpoint,
			&i.MainDocType,
			&i.Extra,
			&i.Signature,
			&i.Nonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentDocumentVersions = `-- name: GetCurrentDocumentVersions :many
SELECT d.uuid, d.current_version, d.updated,
       d.creator_uri, d.updater_uri,
       w.step AS workflow_step, w.checkpoint AS workflow_checkpoint
FROM document AS d
     LEFT OUTER JOIN workflow_state AS w ON w.uuid = d.uuid
WHERE d.uuid = ANY($1::uuid[])
`

type GetCurrentDocumentVersionsRow struct {
	UUID               uuid.UUID
	CurrentVersion     int64
	Updated            pgtype.Timestamptz
	CreatorUri         string
	UpdaterUri         string
	WorkflowStep       pgtype.Text
	WorkflowCheckpoint pgtype.Text
}

func (q *Queries) GetCurrentDocumentVersions(ctx context.Context, uuids []uuid.UUID) ([]GetCurrentDocumentVersionsRow, error) {
	rows, err := q.db.Query(ctx, getCurrentDocumentVersions, uuids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentDocumentVersionsRow
	for rows.Next() {
		var i GetCurrentDocumentVersionsRow
		if err := rows.Scan(
			&i.UUID,
			&i.CurrentVersion,
			&i.Updated,
			&i.CreatorUri,
			&i.UpdaterUri,
			&i.WorkflowStep,
			&i.WorkflowCheckpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelayedScheduled = `-- name: GetDelayedScheduled :many
SELECT
        ws.uuid,
        ws.type,
        s.id AS status_id,
        s.version AS document_version,
        pa.uuid AS assignment,
        pa.planning_item,
        pa.publish AS publish,
        s.creator_uri
FROM workflow_state AS ws
     INNER JOIN planning_deliverable AS pd
           ON pd.document = ws.uuid
     INNER JOIN planning_assignment AS pa
           ON pa.uuid = pd.assignment
     INNER JOIN status_heads AS sh
           ON sh.uuid = ws.uuid
           AND sh.name = 'withheld'
     INNER JOIN document_status AS s
           ON s.uuid = sh.uuid
           AND s.name = sh.name
           AND s.id = sh.current_id
WHERE ws.step = 'withheld'
      AND (
          $1::text[] IS NULL
          OR s.meta->>'source' IS NULL
          OR s.meta->>'source' != ANY($1)
      )
      AND pa.publish < $2
      AND pa.publish > $3
`

type GetDelayedScheduledParams struct {
	NotSource []string
	Before    pgtype.Timestamptz
	Cutoff    pgtype.Timestamptz
}

type GetDelayedScheduledRow struct {
	UUID            uuid.UUID
	Type            string
	StatusID        int64
	DocumentVersion int64
	Assignment      uuid.UUID
	PlanningItem    uuid.UUID
	Publish         pgtype.Timestamptz
	CreatorUri      string
}

func (q *Queries) GetDelayedScheduled(ctx context.Context, arg GetDelayedScheduledParams) ([]GetDelayedScheduledRow, error) {
	rows, err := q.db.Query(ctx, getDelayedScheduled, arg.NotSource, arg.Before, arg.Cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDelayedScheduledRow
	for rows.Next() {
		var i GetDelayedScheduledRow
		if err := rows.Scan(
			&i.UUID,
			&i.Type,
			&i.StatusID,
			&i.DocumentVersion,
			&i.Assignment,
			&i.PlanningItem,
			&i.Publish,
			&i.CreatorUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDelayedScheduledCount = `-- name: GetDelayedScheduledCount :one
SELECT COUNT(*)
FROM workflow_state AS ws
     INNER JOIN planning_deliverable AS pd
           ON pd.document = ws.uuid
     INNER JOIN planning_assignment AS pa
           ON pa.uuid = pd.assignment
     INNER JOIN status_heads AS sh
           ON sh.uuid = ws.uuid
           AND sh.name = 'withheld'
     INNER JOIN document_status AS s
           ON s.uuid = sh.uuid
           AND s.name = sh.name
           AND s.id = sh.current_id
WHERE ws.step = 'withheld'
      AND (
          $1::text[] IS NULL
          OR s.meta->>'source' IS NULL
          OR s.meta->>'source' != ANY($1)
      )
      AND pa.publish < $2
      AND pa.publish > $3
`

type GetDelayedScheduledCountParams struct {
	NotSource []string
	Before    pgtype.Timestamptz
	Cutoff    pgtype.Timestamptz
}

func (q *Queries) GetDelayedScheduledCount(ctx context.Context, arg GetDelayedScheduledCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getDelayedScheduledCount, arg.NotSource, arg.Before, arg.Cutoff)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDeleteRecordForUpdate = `-- name: GetDeleteRecordForUpdate :one
SELECT id, uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, heads, finalised, purged,
       attachments
FROM delete_record
WHERE id = $1 AND uuid = $2
FOR UPDATE
`

type GetDeleteRecordForUpdateParams struct {
	ID   int64
	UUID uuid.UUID
}

type GetDeleteRecordForUpdateRow struct {
	ID            int64
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Heads         map[string]int64
	Finalised     pgtype.Timestamptz
	Purged        pgtype.Timestamptz
	Attachments   []AttachedObject
}

func (q *Queries) GetDeleteRecordForUpdate(ctx context.Context, arg GetDeleteRecordForUpdateParams) (GetDeleteRecordForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDeleteRecordForUpdate, arg.ID, arg.UUID)
	var i GetDeleteRecordForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.URI,
		&i.Type,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.MainDoc,
		&i.Language,
		&i.MetaDocRecord,
		&i.Heads,
		&i.Finalised,
		&i.Purged,
		&i.Attachments,
	)
	return i, err
}

const getDeliverableInfo = `-- name: GetDeliverableInfo :one
SELECT 
       pa.planning_item AS planning_uuid,
       pd.assignment AS assignment_uuid,
       pi.event AS event_uuid
FROM planning_deliverable pd
     JOIN planning_assignment pa
          ON pd.assignment = pa.uuid
     JOIN planning_item pi
          ON pa.planning_item = pi.uuid
WHERE pd.document = $1
`

type GetDeliverableInfoRow struct {
	PlanningUuid   uuid.UUID
	AssignmentUuid uuid.UUID
	EventUuid      pgtype.UUID
}

func (q *Queries) GetDeliverableInfo(ctx context.Context, argUuid uuid.UUID) (GetDeliverableInfoRow, error) {
	row := q.db.QueryRow(ctx, getDeliverableInfo, argUuid)
	var i GetDeliverableInfoRow
	err := row.Scan(&i.PlanningUuid, &i.AssignmentUuid, &i.EventUuid)
	return i, err
}

const getDeliverableTimeranges = `-- name: GetDeliverableTimeranges :many
SELECT a.uuid AS assignment, a.planning_item, a.timerange
FROM planning_deliverable AS d
INNER JOIN planning_assignment AS a
ON a.uuid = d.assignment
WHERE d.document = $1
`

type GetDeliverableTimerangesRow struct {
	Assignment   uuid.UUID
	PlanningItem uuid.UUID
	Timerange    pgtype.Range[pgtype.Timestamptz]
}

func (q *Queries) GetDeliverableTimeranges(ctx context.Context, argUuid uuid.UUID) ([]GetDeliverableTimerangesRow, error) {
	rows, err := q.db.Query(ctx, getDeliverableTimeranges, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliverableTimerangesRow
	for rows.Next() {
		var i GetDeliverableTimerangesRow
		if err := rows.Scan(&i.Assignment, &i.PlanningItem, &i.Timerange); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliverableTimes = `-- name: GetDeliverableTimes :many
SELECT a.full_day, a.publish, a.starts, a.ends, a.start_date, a.end_date, a.timezone
FROM planning_deliverable AS d
INNER JOIN planning_assignment AS a
ON a.uuid = d.assignment
WHERE d.document = $1
`

type GetDeliverableTimesRow struct {
	FullDay   bool
	Publish   pgtype.Timestamptz
	Starts    pgtype.Timestamptz
	Ends      pgtype.Timestamptz
	StartDate pgtype.Date
	EndDate   pgtype.Date
	Timezone  pgtype.Text
}

func (q *Queries) GetDeliverableTimes(ctx context.Context, argUuid uuid.UUID) ([]GetDeliverableTimesRow, error) {
	rows, err := q.db.Query(ctx, getDeliverableTimes, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeliverableTimesRow
	for rows.Next() {
		var i GetDeliverableTimesRow
		if err := rows.Scan(
			&i.FullDay,
			&i.Publish,
			&i.Starts,
			&i.Ends,
			&i.StartDate,
			&i.EndDate,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeprecations = `-- name: GetDeprecations :many
SELECT label, enforced
FROM deprecation
ORDER BY label
`

func (q *Queries) GetDeprecations(ctx context.Context) ([]Deprecation, error) {
	rows, err := q.db.Query(ctx, getDeprecations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deprecation
	for rows.Next() {
		var i Deprecation
		if err := rows.Scan(&i.Label, &i.Enforced); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

func (q *Queries) GetDocumentACL(ctx context.Context, argUuid uuid.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.UUID, &i.URI, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentAttachmentDetails = `-- name: GetDocumentAttachmentDetails :many
SELECT
        o.document,
        o.name,
        o.version,
        o.object_version,
        o.attached_at,
        o.created_by,
        o.created_at,
        o.meta
FROM attached_object_current AS c
     INNER JOIN attached_object AS o ON
           o.document = c.document
           AND o.name = c.name
           AND o.version = c.version
WHERE c.document = $1
      AND c.deleted = false
`

func (q *Queries) GetDocumentAttachmentDetails(ctx context.Context, document uuid.UUID) ([]AttachedObject, error) {
	rows, err := q.db.Query(ctx, getDocumentAttachmentDetails, document)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AttachedObject
	for rows.Next() {
		var i AttachedObject
		if err := rows.Scan(
			&i.Document,
			&i.Name,
			&i.Version,
			&i.ObjectVersion,
			&i.AttachedAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentData = `-- name: GetDocumentData :one
SELECT v.document_data, v.version
FROM document as d
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid And v.version = d.current_version
WHERE d.uuid = $1
`

type GetDocumentDataRow struct {
	DocumentData []byte
	Version      int64
}

func (q *Queries) GetDocumentData(ctx context.Context, argUuid uuid.UUID) (GetDocumentDataRow, error) {
	row := q.db.QueryRow(ctx, getDocumentData, argUuid)
	var i GetDocumentDataRow
	err := row.Scan(&i.DocumentData, &i.Version)
	return i, err
}

const getDocumentForDeletion = `-- name: GetDocumentForDeletion :one
SELECT dr.id, dr.uuid, dr.nonce, dr.heads, dr.acl, dr.version, dr.attachments
FROM delete_record AS dr
WHERE dr.finalised IS NULL
ORDER BY dr.created
FOR UPDATE SKIP LOCKED -- locks both rows
LIMIT 1
`

type GetDocumentForDeletionRow struct {
	ID          int64
	UUID        uuid.UUID
	Nonce       uuid.UUID
	Heads       map[string]int64
	Acl         []ACLEntry
	Version     int64
	Attachments []AttachedObject
}

func (q *Queries) GetDocumentForDeletion(ctx context.Context) (GetDocumentForDeletionRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForDeletion)
	var i GetDocumentForDeletionRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.Nonce,
		&i.Heads,
		&i.Acl,
		&i.Version,
		&i.Attachments,
	)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
SELECT d.uri, d.type, d.current_version, d.main_doc, d.language, d.system_state,
       d.nonce AS nonce,
       l.uuid as lock_uuid, l.uri as lock_uri, l.created as lock_created,
       l.expires as lock_expires, l.app as lock_app, l.comment as lock_comment,
       l.token as lock_token
FROM document as d
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $2
WHERE d.uuid = $1
FOR UPDATE OF d
`

type GetDocumentForUpdateParams struct {
	UUID uuid.UUID
	Now  pgtype.Timestamptz
}

type GetDocumentForUpdateRow struct {
	URI            string
	Type           string
	CurrentVersion int64
	MainDoc        pgtype.UUID
	Language       pgtype.Text
	SystemState    pgtype.Text
	Nonce          uuid.UUID
	LockUuid       pgtype.UUID
	LockUri        pgtype.Text
	LockCreated    pgtype.Timestamptz
	LockExpires    pgtype.Timestamptz
	LockApp        pgtype.Text
	LockComment    pgtype.Text
	LockToken      pgtype.Text
}

func (q *Queries) GetDocumentForUpdate(ctx context.Context, arg GetDocumentForUpdateParams) (GetDocumentForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, arg.UUID, arg.Now)
	var i GetDocumentForUpdateRow
	err := row.Scan(
		&i.URI,
		&i.Type,
		&i.CurrentVersion,
		&i.MainDoc,
		&i.Language,
		&i.SystemState,
		&i.Nonce,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
	)
	return i, err
}

const getDocumentHeads = `-- name: GetDocumentHeads :many
SELECT name, current_id
FROM status_heads
WHERE uuid = $1
`

type GetDocumentHeadsRow struct {
	Name      string
	CurrentID int64
}

func (q *Queries) GetDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]GetDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentHeadsRow
	for rows.Next() {
		var i GetDocumentHeadsRow
		if err := rows.Scan(&i.Name, &i.CurrentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentInfo = `-- name: GetDocumentInfo :one
SELECT
        d.uuid, d.uri, d.created, d.creator_uri, d.updated, d.updater_uri, d.current_version,
        d.system_state, d.main_doc, d.nonce, l.uuid as lock_uuid, l.uri as lock_uri,
        l.created as lock_created, l.expires as lock_expires, l.app as lock_app,
        l.comment as lock_comment, l.token as lock_token,
        ws.step as workflow_state, ws.checkpoint as workflow_checkpoint
FROM document as d 
LEFT JOIN document_lock as l ON d.uuid = l.uuid AND l.expires > $1
LEFT JOIN workflow_state AS ws ON ws.uuid = d.uuid
WHERE d.uuid = $2
`

type GetDocumentInfoParams struct {
	Now  pgtype.Timestamptz
	UUID uuid.UUID
}

type GetDocumentInfoRow struct {
	UUID               uuid.UUID
	URI                string
	Created            pgtype.Timestamptz
	CreatorUri         string
	Updated            pgtype.Timestamptz
	UpdaterUri         string
	CurrentVersion     int64
	SystemState        pgtype.Text
	MainDoc            pgtype.UUID
	Nonce              uuid.UUID
	LockUuid           pgtype.UUID
	LockUri            pgtype.Text
	LockCreated        pgtype.Timestamptz
	LockExpires        pgtype.Timestamptz
	LockApp            pgtype.Text
	LockComment        pgtype.Text
	LockToken          pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
}

func (q *Queries) GetDocumentInfo(ctx context.Context, arg GetDocumentInfoParams) (GetDocumentInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentInfo, arg.Now, arg.UUID)
	var i GetDocumentInfoRow
	err := row.Scan(
		&i.UUID,
		&i.URI,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.SystemState,
		&i.MainDoc,
		&i.Nonce,
		&i.LockUuid,
		&i.LockUri,
		&i.LockCreated,
		&i.LockExpires,
		&i.LockApp,
		&i.LockComment,
		&i.LockToken,
		&i.WorkflowState,
		&i.WorkflowCheckpoint,
	)
	return i, err
}

const getDocumentLog = `-- name: GetDocumentLog :many
SELECT e.id, e.event, e.uuid, e.timestamp, e.type, e.version, e.status,
       e.status_id, e.acl, e.updater, e.language, e.old_language, e.main_doc,
       e.system_state, e.workflow_state, e.workflow_checkpoint, e.main_doc_type,
       e.extra, e.signature
FROM eventlog AS e
     LEFT OUTER JOIN document AS d
           ON e.event = 'documen'
              AND d.uuid = e.uuid
              AND e.nonce = d.nonce
              AND e.version = d.current_version
WHERE e.id > $1
      AND (d.uuid IS NOT NULL OR e.event = 'delete')
ORDER BY e.id ASC
LIMIT $2
`

type GetDocumentLogParams struct {
	After    int64
	RowLimit int32
}

type GetDocumentLogRow struct {
	ID                 int64
	Event              string
	UUID               uuid.UUID
	Timestamp          pgtype.Timestamptz
	Type               pgtype.Text
	Version            pgtype.Int8
	Status             pgtype.Text
	StatusID           pgtype.Int8
	Acl                []byte
	Updater            pgtype.Text
	Language           pgtype.Text
	OldLanguage        pgtype.Text
	MainDoc            pgtype.UUID
	SystemState        pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
	MainDocType        pgtype.Text
	Extra              *EventlogExtra
	Signature          pgtype.Text
}

func (q *Queries) GetDocumentLog(ctx context.Context, arg GetDocumentLogParams) ([]GetDocumentLogRow, error) {
	rows, err := q.db.Query(ctx, getDocumentLog, arg.After, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentLogRow
	for rows.Next() {
		var i GetDocumentLogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
			&i.SystemState,
			&i.WorkflowState,
			&i.WorkflowCheckpoint,
			&i.MainDocType,
			&i.Extra,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentRow = `-- name: GetDocumentRow :one
SELECT uuid, uri, type, created, creator_uri, updated, updater_uri,
       current_version, main_doc, language, system_state, nonce,
       time, labels
FROM document
WHERE uuid = $1
`

type GetDocumentRowRow struct {
	UUID           uuid.UUID
	URI            string
	Type           string
	Created        pgtype.Timestamptz
	CreatorUri     string
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	CurrentVersion int64
	MainDoc        pgtype.UUID
	Language       pgtype.Text
	SystemState    pgtype.Text
	Nonce          uuid.UUID
	Time           pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	Labels         []string
}

func (q *Queries) GetDocumentRow(ctx context.Context, argUuid uuid.UUID) (GetDocumentRowRow, error) {
	row := q.db.QueryRow(ctx, getDocumentRow, argUuid)
	var i GetDocumentRowRow
	err := row.Scan(
		&i.UUID,
		&i.URI,
		&i.Type,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.MainDoc,
		&i.Language,
		&i.SystemState,
		&i.Nonce,
		&i.Time,
		&i.Labels,
	)
	return i, err
}

const getDocumentSearchInfo = `-- name: GetDocumentSearchInfo :one
SELECT time, labels
FROM document
WHERE uuid = $1
`

type GetDocumentSearchInfoRow struct {
	Time   pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	Labels []string
}

func (q *Queries) GetDocumentSearchInfo(ctx context.Context, argUuid uuid.UUID) (GetDocumentSearchInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentSearchInfo, argUuid)
	var i GetDocumentSearchInfoRow
	err := row.Scan(&i.Time, &i.Labels)
	return i, err
}

const getDocumentStatusForArchiving = `-- name: GetDocumentStatusForArchiving :one
SELECT
        s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
        s.meta_doc_version, p.signature AS parent_signature, d.nonce
FROM document_status AS s
     INNER JOIN document AS d
           ON d.uuid = s.uuid
     LEFT JOIN document_status AS p
          ON p.uuid = s.uuid AND p.name = s.name AND p.id = s.id-1
WHERE s.uuid = $1 AND s.name = $2 AND s.id = $3
`

type GetDocumentStatusForArchivingParams struct {
	UUID uuid.UUID
	Name string
	ID   int64
}

type GetDocumentStatusForArchivingRow struct {
	UUID            uuid.UUID
	Name            string
	ID              int64
	Version         int64
	Created         pgtype.Timestamptz
	CreatorUri      string
	Meta            map[string]string
	MetaDocVersion  pgtype.Int8
	ParentSignature pgtype.Text
	Nonce           uuid.UUID
}

func (q *Queries) GetDocumentStatusForArchiving(ctx context.Context, arg GetDocumentStatusForArchivingParams) (GetDocumentStatusForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentStatusForArchiving, arg.UUID, arg.Name, arg.ID)
	var i GetDocumentStatusForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Name,
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.MetaDocVersion,
		&i.ParentSignature,
		&i.Nonce,
	)
	return i, err
}

const getDocumentUnarchivedCount = `-- name: GetDocumentUnarchivedCount :one
SELECT unarchived FROM document_archive_counter
WHERE uuid = $1
`

func (q *Queries) GetDocumentUnarchivedCount(ctx context.Context, argUuid uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getDocumentUnarchivedCount, argUuid)
	var unarchived int32
	err := row.Scan(&unarchived)
	return unarchived, err
}

const getDocumentVersionData = `-- name: GetDocumentVersionData :one
SELECT document_data
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetDocumentVersionDataParams struct {
	UUID    uuid.UUID
	Version int64
}

func (q *Queries) GetDocumentVersionData(ctx context.Context, arg GetDocumentVersionDataParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionData, arg.UUID, arg.Version)
	var document_data []byte
	err := row.Scan(&document_data)
	return document_data, err
}

const getDocumentVersionForArchiving = `-- name: GetDocumentVersionForArchiving :one
SELECT
        v.uuid, v.version, v.created, v.creator_uri, v.meta, v.document_data,
        p.signature AS parent_signature, d.main_doc, d.uri, d.type,
        v.language AS language, d.nonce
FROM document_version AS v
     LEFT JOIN document_version AS p
          ON p.uuid = v.uuid AND p.version = v.version-1
     INNER JOIN document AS d
          ON d.uuid = v.uuid
WHERE v.uuid = $1 AND v.version = $2
`

type GetDocumentVersionForArchivingParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetDocumentVersionForArchivingRow struct {
	UUID            uuid.UUID
	Version         int64
	Created         pgtype.Timestamptz
	CreatorUri      string
	Meta            []byte
	DocumentData    []byte
	ParentSignature pgtype.Text
	MainDoc         pgtype.UUID
	URI             string
	Type            string
	Language        pgtype.Text
	Nonce           uuid.UUID
}

func (q *Queries) GetDocumentVersionForArchiving(ctx context.Context, arg GetDocumentVersionForArchivingParams) (GetDocumentVersionForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionForArchiving, arg.UUID, arg.Version)
	var i GetDocumentVersionForArchivingRow
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.ParentSignature,
		&i.MainDoc,
		&i.URI,
		&i.Type,
		&i.Language,
		&i.Nonce,
	)
	return i, err
}

const getDocumentVersionSearchInfo = `-- name: GetDocumentVersionSearchInfo :one
SELECT time, labels
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetDocumentVersionSearchInfoParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetDocumentVersionSearchInfoRow struct {
	Time   pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	Labels []string
}

func (q *Queries) GetDocumentVersionSearchInfo(ctx context.Context, arg GetDocumentVersionSearchInfoParams) (GetDocumentVersionSearchInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionSearchInfo, arg.UUID, arg.Version)
	var i GetDocumentVersionSearchInfoRow
	err := row.Scan(&i.Time, &i.Labels)
	return i, err
}

const getDocumentWorkflow = `-- name: GetDocumentWorkflow :one
SELECT type, updated, updater_uri, configuration
FROM workflow
WHERE type = $1
`

func (q *Queries) GetDocumentWorkflow(ctx context.Context, type_ string) (Workflow, error) {
	row := q.db.QueryRow(ctx, getDocumentWorkflow, type_)
	var i Workflow
	err := row.Scan(
		&i.Type,
		&i.Updated,
		&i.UpdaterUri,
		&i.Configuration,
	)
	return i, err
}

const getDocumentWorkflows = `-- name: GetDocumentWorkflows :many
SELECT type, updated, updater_uri, configuration
FROM workflow
`

func (q *Queries) GetDocumentWorkflows(ctx context.Context) ([]Workflow, error) {
	rows, err := q.db.Query(ctx, getDocumentWorkflows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workflow
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.Type,
			&i.Updated,
			&i.UpdaterUri,
			&i.Configuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnforcedDeprecations = `-- name: GetEnforcedDeprecations :many
SELECT label
FROM deprecation
WHERE enforced = true
`

func (q *Queries) GetEnforcedDeprecations(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getEnforcedDeprecations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var label string
		if err := rows.Scan(&label); err != nil {
			return nil, err
		}
		items = append(items, label)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventlog = `-- name: GetEventlog :many
SELECT id, event, uuid, timestamp, type, version, status, status_id, acl, updater,
       language, old_language, main_doc, system_state,
       workflow_state, workflow_checkpoint, main_doc_type, extra, signature, nonce
FROM eventlog
WHERE id > $1
ORDER BY id ASC
LIMIT $2
`

type GetEventlogParams struct {
	After    int64
	RowLimit int32
}

type GetEventlogRow struct {
	ID                 int64
	Event              string
	UUID               uuid.UUID
	Timestamp          pgtype.Timestamptz
	Type               pgtype.Text
	Version            pgtype.Int8
	Status             pgtype.Text
	StatusID           pgtype.Int8
	Acl                []byte
	Updater            pgtype.Text
	Language           pgtype.Text
	OldLanguage        pgtype.Text
	MainDoc            pgtype.UUID
	SystemState        pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
	MainDocType        pgtype.Text
	Extra              *EventlogExtra
	Signature          pgtype.Text
	Nonce              uuid.UUID
}

func (q *Queries) GetEventlog(ctx context.Context, arg GetEventlogParams) ([]GetEventlogRow, error) {
	rows, err := q.db.Query(ctx, getEventlog, arg.After, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventlogRow
	for rows.Next() {
		var i GetEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.UUID,
			&i.Timestamp,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
			&i.Updater,
			&i.Language,
			&i.OldLanguage,
			&i.MainDoc,
			&i.SystemState,
			&i.WorkflowState,
			&i.WorkflowCheckpoint,
			&i.MainDocType,
			&i.Extra,
			&i.Signature,
			&i.Nonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventlogArchiver = `-- name: GetEventlogArchiver :one
SELECT position, last_signature FROM eventlog_archiver
WHERE size = $1
`

type GetEventlogArchiverRow struct {
	Position      int64
	LastSignature string
}

func (q *Queries) GetEventlogArchiver(ctx context.Context, size int64) (GetEventlogArchiverRow, error) {
	row := q.db.QueryRow(ctx, getEventlogArchiver, size)
	var i GetEventlogArchiverRow
	err := row.Scan(&i.Position, &i.LastSignature)
	return i, err
}

const getEventsinkPosition = `-- name: GetEventsinkPosition :one
SELECT position FROM eventsink WHERE name = $1
`

func (q *Queries) GetEventsinkPosition(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getEventsinkPosition, name)
	var position int64
	err := row.Scan(&position)
	return position, err
}

const getExpiredDocumentLocks = `-- name: GetExpiredDocumentLocks :many
SELECT d.uuid, l.expires AS lock_expires, l.app
FROM document_lock AS l
       INNER JOIN document AS d ON d.uuid = l.uuid
WHERE l.expires < $1
FOR UPDATE OF d SKIP LOCKED
`

type GetExpiredDocumentLocksRow struct {
	UUID        uuid.UUID
	LockExpires pgtype.Timestamptz
	App         pgtype.Text
}

func (q *Queries) GetExpiredDocumentLocks(ctx context.Context, cutoff pgtype.Timestamptz) ([]GetExpiredDocumentLocksRow, error) {
	rows, err := q.db.Query(ctx, getExpiredDocumentLocks, cutoff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiredDocumentLocksRow
	for rows.Next() {
		var i GetExpiredDocumentLocksRow
		if err := rows.Scan(&i.UUID, &i.LockExpires, &i.App); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullDocumentHeads = `-- name: GetFullDocumentHeads :many
SELECT s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
       s.archived, s.signature, s.meta_doc_version, h.language
FROM status_heads AS h
     INNER JOIN document_status AS s ON
           s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = $1
`

type GetFullDocumentHeadsRow struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	Archived       bool
	Signature      pgtype.Text
	MetaDocVersion pgtype.Int8
	Language       pgtype.Text
}

func (q *Queries) GetFullDocumentHeads(ctx context.Context, argUuid uuid.UUID) ([]GetFullDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getFullDocumentHeads, argUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFullDocumentHeadsRow
	for rows.Next() {
		var i GetFullDocumentHeadsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
			&i.Signature,
			&i.MetaDocVersion,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullVersion = `-- name: GetFullVersion :one
SELECT created, creator_uri, meta, document_data, archived, signature
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetFullVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetFullVersionRow struct {
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Archived     bool
	Signature    pgtype.Text
}

func (q *Queries) GetFullVersion(ctx context.Context, arg GetFullVersionParams) (GetFullVersionRow, error) {
	row := q.db.QueryRow(ctx, getFullVersion, arg.UUID, arg.Version)
	var i GetFullVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.Archived,
		&i.Signature,
	)
	return i, err
}

const getInvalidRestoreRequests = `-- name: GetInvalidRestoreRequests :many
SELECT r.id
FROM restore_request AS r
     INNER JOIN delete_record AS dr
           ON dr.id = r.delete_record_id
WHERE r.finished IS NULL AND dr.purged IS NOT NULL
ORDER BY r.id ASC
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetInvalidRestoreRequests(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getInvalidRestoreRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobLock = `-- name: GetJobLock :one
SELECT holder, touched, iteration
FROM job_lock
WHERE name = $1
FOR UPDATE
`

type GetJobLockRow struct {
	Holder    string
	Touched   pgtype.Timestamptz
	Iteration int64
}

func (q *Queries) GetJobLock(ctx context.Context, name string) (GetJobLockRow, error) {
	row := q.db.QueryRow(ctx, getJobLock, name)
	var i GetJobLockRow
	err := row.Scan(&i.Holder, &i.Touched, &i.Iteration)
	return i, err
}

const getLastEvent = `-- name: GetLastEvent :one
SELECT id, event, uuid, timestamp, updater, type, version, status, status_id, acl,
       language, old_language, main_doc, workflow_state, workflow_checkpoint, main_doc_type,
       extra, signature
FROM eventlog
ORDER BY id DESC
LIMIT 1
`

type GetLastEventRow struct {
	ID                 int64
	Event              string
	UUID               uuid.UUID
	Timestamp          pgtype.Timestamptz
	Updater            pgtype.Text
	Type               pgtype.Text
	Version            pgtype.Int8
	Status             pgtype.Text
	StatusID           pgtype.Int8
	Acl                []byte
	Language           pgtype.Text
	OldLanguage        pgtype.Text
	MainDoc            pgtype.UUID
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
	MainDocType        pgtype.Text
	Extra              *EventlogExtra
	Signature          pgtype.Text
}

func (q *Queries) GetLastEvent(ctx context.Context) (GetLastEventRow, error) {
	row := q.db.QueryRow(ctx, getLastEvent)
	var i GetLastEventRow
	err := row.Scan(
		&i.ID,
		&i.Event,
		&i.UUID,
		&i.Timestamp,
		&i.Updater,
		&i.Type,
		&i.Version,
		&i.Status,
		&i.StatusID,
		&i.Acl,
		&i.Language,
		&i.OldLanguage,
		&i.MainDoc,
		&i.WorkflowState,
		&i.WorkflowCheckpoint,
		&i.MainDocType,
		&i.Extra,
		&i.Signature,
	)
	return i, err
}

const getLastEventID = `-- name: GetLastEventID :one
SELECT id FROM eventlog
ORDER BY id DESC LIMIT 1
`

func (q *Queries) GetLastEventID(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLastEventID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getMetaDocVersion = `-- name: GetMetaDocVersion :one
SELECT current_version FROM document
WHERE main_doc = $1
`

func (q *Queries) GetMetaDocVersion(ctx context.Context, argUuid pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getMetaDocVersion, argUuid)
	var current_version int64
	err := row.Scan(&current_version)
	return current_version, err
}

const getMetaTypeUse = `-- name: GetMetaTypeUse :many
SELECT main_type, meta_type
FROM meta_type_use
`

func (q *Queries) GetMetaTypeUse(ctx context.Context) ([]MetaTypeUse, error) {
	rows, err := q.db.Query(ctx, getMetaTypeUse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetaTypeUse
	for rows.Next() {
		var i MetaTypeUse
		if err := rows.Scan(&i.MainType, &i.MetaType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetaTypesWithUse = `-- name: GetMetaTypesWithUse :many
SELECT m.meta_type, u.main_type
       FROM meta_type AS m
       LEFT OUTER JOIN meta_type_use AS u ON u.meta_type = m.meta_type
`

type GetMetaTypesWithUseRow struct {
	MetaType string
	MainType pgtype.Text
}

func (q *Queries) GetMetaTypesWithUse(ctx context.Context) ([]GetMetaTypesWithUseRow, error) {
	rows, err := q.db.Query(ctx, getMetaTypesWithUse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMetaTypesWithUseRow
	for rows.Next() {
		var i GetMetaTypesWithUseRow
		if err := rows.Scan(&i.MetaType, &i.MainType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricKind = `-- name: GetMetricKind :one
SELECT name, aggregation
FROM metric_kind 
WHERE name = $1
`

func (q *Queries) GetMetricKind(ctx context.Context, name string) (MetricKind, error) {
	row := q.db.QueryRow(ctx, getMetricKind, name)
	var i MetricKind
	err := row.Scan(&i.Name, &i.Aggregation)
	return i, err
}

const getMetricKinds = `-- name: GetMetricKinds :many
SELECT name, aggregation
FROM metric_kind 
ORDER BY name
`

func (q *Queries) GetMetricKinds(ctx context.Context) ([]MetricKind, error) {
	rows, err := q.db.Query(ctx, getMetricKinds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MetricKind
	for rows.Next() {
		var i MetricKind
		if err := rows.Scan(&i.Name, &i.Aggregation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetrics = `-- name: GetMetrics :many
SELECT uuid, kind, label, value
FROM metric
WHERE uuid = ANY($1::uuid[])
      AND ($2::text[] IS NULL OR kind = ANY($2::text[]))
`

type GetMetricsParams struct {
	UUID []uuid.UUID
	Kind []string
}

func (q *Queries) GetMetrics(ctx context.Context, arg GetMetricsParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetrics, arg.UUID, arg.Kind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.UUID,
			&i.Kind,
			&i.Label,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMultipleStatusHeads = `-- name: GetMultipleStatusHeads :many
SELECT h.uuid, h.name, h.current_id, h.updated, h.updater_uri, s.version,
       s.meta_doc_version,
       CASE WHEN $1::bool THEN s.meta ELSE NULL::jsonb END AS meta
FROM status_heads AS h
     INNER JOIN document_status AS s
           ON s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = ANY($2::uuid[])
AND h.name = ANY($3::text[])
`

type GetMultipleStatusHeadsParams struct {
	GetMeta  bool
	Uuids    []uuid.UUID
	Statuses []string
}

type GetMultipleStatusHeadsRow struct {
	UUID           uuid.UUID
	Name           string
	CurrentID      int64
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	Version        int64
	MetaDocVersion pgtype.Int8
	Meta           []byte
}

func (q *Queries) GetMultipleStatusHeads(ctx context.Context, arg GetMultipleStatusHeadsParams) ([]GetMultipleStatusHeadsRow, error) {
	rows, err := q.db.Query(ctx, getMultipleStatusHeads, arg.GetMeta, arg.Uuids, arg.Statuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMultipleStatusHeadsRow
	for rows.Next() {
		var i GetMultipleStatusHeadsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.CurrentID,
			&i.Updated,
			&i.UpdaterUri,
			&i.Version,
			&i.MetaDocVersion,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextPurgeRequest = `-- name: GetNextPurgeRequest :one
SELECT p.id, p.uuid, p.delete_record_id, p.created
FROM purge_request AS p
     INNER JOIN delete_record AS dr
           ON dr.id = p.delete_record_id
WHERE p.finished IS NULL
      AND dr.purged IS NULL
      AND dr.finalised IS NOT NULL
ORDER BY p.id ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetNextPurgeRequestRow struct {
	ID             int64
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
}

func (q *Queries) GetNextPurgeRequest(ctx context.Context) (GetNextPurgeRequestRow, error) {
	row := q.db.QueryRow(ctx, getNextPurgeRequest)
	var i GetNextPurgeRequestRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.DeleteRecordID,
		&i.Created,
	)
	return i, err
}

const getNextRestoreRequest = `-- name: GetNextRestoreRequest :one
SELECT r.id, r.uuid, d.nonce, r.delete_record_id, r.created, r.creator, r.spec
FROM restore_request AS r
     INNER JOIN delete_record AS dr
           ON dr.id = r.delete_record_id
     INNER JOIN document AS d
           ON d.uuid = r.uuid AND d.system_state = 'restoring'
WHERE r.finished IS NULL AND dr.purged IS NULL
ORDER BY r.id ASC
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetNextRestoreRequestRow struct {
	ID             int64
	UUID           uuid.UUID
	Nonce          uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
	Spec           []byte
}

func (q *Queries) GetNextRestoreRequest(ctx context.Context) (GetNextRestoreRequestRow, error) {
	row := q.db.QueryRow(ctx, getNextRestoreRequest)
	var i GetNextRestoreRequestRow
	err := row.Scan(
		&i.ID,
		&i.UUID,
		&i.Nonce,
		&i.DeleteRecordID,
		&i.Created,
		&i.Creator,
		&i.Spec,
	)
	return i, err
}

const getNilStatuses = `-- name: GetNilStatuses :many
SELECT uuid, name, id, version, created, creator_uri, meta, meta_doc_version
FROM document_status
WHERE uuid = $1
      AND ($2::text[] IS NULL OR name = ANY($2))
      AND version = -1
ORDER BY name ASC, id DESC
`

type GetNilStatusesParams struct {
	UUID  uuid.UUID
	Names []string
}

type GetNilStatusesRow struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	MetaDocVersion pgtype.Int8
}

func (q *Queries) GetNilStatuses(ctx context.Context, arg GetNilStatusesParams) ([]GetNilStatusesRow, error) {
	rows, err := q.db.Query(ctx, getNilStatuses, arg.UUID, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNilStatusesRow
	for rows.Next() {
		var i GetNilStatusesRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.MetaDocVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanningAssignment = `-- name: GetPlanningAssignment :one
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description,
       timezone, timerange
FROM planning_assignment
WHERE uuid = $1
`

func (q *Queries) GetPlanningAssignment(ctx context.Context, argUuid uuid.UUID) (PlanningAssignment, error) {
	row := q.db.QueryRow(ctx, getPlanningAssignment, argUuid)
	var i PlanningAssignment
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.PlanningItem,
		&i.Status,
		&i.Publish,
		&i.PublishSlot,
		&i.Starts,
		&i.Ends,
		&i.StartDate,
		&i.EndDate,
		&i.FullDay,
		&i.Public,
		&i.Kind,
		&i.Description,
		&i.Timezone,
		&i.Timerange,
	)
	return i, err
}

const getPlanningAssignments = `-- name: GetPlanningAssignments :many
SELECT uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description
FROM planning_assignment
WHERE planning_item = $1
`

type GetPlanningAssignmentsRow struct {
	UUID         uuid.UUID
	Version      int64
	PlanningItem uuid.UUID
	Status       pgtype.Text
	Publish      pgtype.Timestamptz
	PublishSlot  pgtype.Int2
	Starts       pgtype.Timestamptz
	Ends         pgtype.Timestamptz
	StartDate    pgtype.Date
	EndDate      pgtype.Date
	FullDay      bool
	Public       bool
	Kind         []string
	Description  string
}

func (q *Queries) GetPlanningAssignments(ctx context.Context, planningItem uuid.UUID) ([]GetPlanningAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, getPlanningAssignments, planningItem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlanningAssignmentsRow
	for rows.Next() {
		var i GetPlanningAssignmentsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.PlanningItem,
			&i.Status,
			&i.Publish,
			&i.PublishSlot,
			&i.Starts,
			&i.Ends,
			&i.StartDate,
			&i.EndDate,
			&i.FullDay,
			&i.Public,
			&i.Kind,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanningItem = `-- name: GetPlanningItem :one
SELECT
        uuid, version, title, description, public, tentative,
        start_date, end_date, priority, event
FROM planning_item
WHERE uuid = $1
`

type GetPlanningItemRow struct {
	UUID        uuid.UUID
	Version     int64
	Title       string
	Description string
	Public      pgtype.Bool
	Tentative   bool
	StartDate   pgtype.Date
	EndDate     pgtype.Date
	Priority    pgtype.Int2
	Event       pgtype.UUID
}

func (q *Queries) GetPlanningItem(ctx context.Context, argUuid uuid.UUID) (GetPlanningItemRow, error) {
	row := q.db.QueryRow(ctx, getPlanningItem, argUuid)
	var i GetPlanningItemRow
	err := row.Scan(
		&i.UUID,
		&i.Version,
		&i.Title,
		&i.Description,
		&i.Public,
		&i.Tentative,
		&i.StartDate,
		&i.EndDate,
		&i.Priority,
		&i.Event,
	)
	return i, err
}

const getScheduled = `-- name: GetScheduled :many
SELECT
        ws.uuid,
        ws.type,
        s.id AS status_id,
        s.version AS document_version,
        pa.uuid AS assignment,
        pa.planning_item,
        pa.publish AS publish,
        s.creator_uri
FROM workflow_state AS ws
     INNER JOIN planning_deliverable AS pd
           ON pd.document = ws.uuid
     INNER JOIN planning_assignment AS pa
           ON pa.uuid = pd.assignment
     INNER JOIN status_heads AS sh
           ON sh.uuid = ws.uuid
           AND sh.name = 'withheld'
     INNER JOIN document_status AS s
           ON s.uuid = sh.uuid
           AND s.name = sh.name
           AND s.id = sh.current_id
WHERE ws.step = 'withheld'
      AND (
          $1::text[] IS NULL
          OR s.meta->>'source' IS NULL
          OR s.meta->>'source' != ANY($1)
      )
      AND pa.publish > $2
ORDER BY pa.publish ASC
LIMIT 10
`

type GetScheduledParams struct {
	NotSource []string
	After     pgtype.Timestamptz
}

type GetScheduledRow struct {
	UUID            uuid.UUID
	Type            string
	StatusID        int64
	DocumentVersion int64
	Assignment      uuid.UUID
	PlanningItem    uuid.UUID
	Publish         pgtype.Timestamptz
	CreatorUri      string
}

func (q *Queries) GetScheduled(ctx context.Context, arg GetScheduledParams) ([]GetScheduledRow, error) {
	rows, err := q.db.Query(ctx, getScheduled, arg.NotSource, arg.After)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduledRow
	for rows.Next() {
		var i GetScheduledRow
		if err := rows.Scan(
			&i.UUID,
			&i.Type,
			&i.StatusID,
			&i.DocumentVersion,
			&i.Assignment,
			&i.PlanningItem,
			&i.Publish,
			&i.CreatorUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchema = `-- name: GetSchema :one
SELECT s.name, s.version, s.spec
FROM document_schema AS s
WHERE s.name = $1 AND s.version = $2
`

type GetSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) GetSchema(ctx context.Context, arg GetSchemaParams) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getSchema, arg.Name, arg.Version)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getSchemaVersions = `-- name: GetSchemaVersions :many
SELECT a.name, a.version
FROM active_schemas AS a
`

func (q *Queries) GetSchemaVersions(ctx context.Context) ([]ActiveSchema, error) {
	rows, err := q.db.Query(ctx, getSchemaVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveSchema
	for rows.Next() {
		var i ActiveSchema
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSigningKeys = `-- name: GetSigningKeys :many
SELECT kid, spec FROM signing_keys
`

func (q *Queries) GetSigningKeys(ctx context.Context) ([]SigningKey, error) {
	rows, err := q.db.Query(ctx, getSigningKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SigningKey
	for rows.Next() {
		var i SigningKey
		if err := rows.Scan(&i.Kid, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatus = `-- name: GetStatus :one
SELECT id, version, created, creator_uri, meta, meta_doc_version
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id = $3::bigint)
ORDER BY id DESC
LIMIT 1
`

type GetStatusParams struct {
	UUID uuid.UUID
	Name string
	ID   int64
}

type GetStatusRow struct {
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	MetaDocVersion pgtype.Int8
}

func (q *Queries) GetStatus(ctx context.Context, arg GetStatusParams) (GetStatusRow, error) {
	row := q.db.QueryRow(ctx, getStatus, arg.UUID, arg.Name, arg.ID)
	var i GetStatusRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.MetaDocVersion,
	)
	return i, err
}

const getStatusRules = `-- name: GetStatusRules :many
SELECT type, name, description, access_rule, applies_to, expression
FROM status_rule
`

func (q *Queries) GetStatusRules(ctx context.Context) ([]StatusRule, error) {
	rows, err := q.db.Query(ctx, getStatusRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatusRule
	for rows.Next() {
		var i StatusRule
		if err := rows.Scan(
			&i.Type,
			&i.Name,
			&i.Description,
			&i.AccessRule,
			&i.AppliesTo,
			&i.Expression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusVersions = `-- name: GetStatusVersions :many
SELECT id, version, created, creator_uri, meta, meta_doc_version
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id < $3::bigint)
ORDER BY id DESC
LIMIT $4
`

type GetStatusVersionsParams struct {
	UUID   uuid.UUID
	Name   string
	Before int64
	Count  int32
}

type GetStatusVersionsRow struct {
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	MetaDocVersion pgtype.Int8
}

func (q *Queries) GetStatusVersions(ctx context.Context, arg GetStatusVersionsParams) ([]GetStatusVersionsRow, error) {
	rows, err := q.db.Query(ctx, getStatusVersions,
		arg.UUID,
		arg.Name,
		arg.Before,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusVersionsRow
	for rows.Next() {
		var i GetStatusVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.MetaDocVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusesForVersions = `-- name: GetStatusesForVersions :many
SELECT uuid, name, id, version, created, creator_uri, meta, meta_doc_version
FROM document_status
WHERE uuid = $1 AND version = ANY($2::bigint[])
ORDER BY version DESC, name, id DESC
`

type GetStatusesForVersionsParams struct {
	UUID     uuid.UUID
	Versions []int64
}

type GetStatusesForVersionsRow struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	MetaDocVersion pgtype.Int8
}

func (q *Queries) GetStatusesForVersions(ctx context.Context, arg GetStatusesForVersionsParams) ([]GetStatusesForVersionsRow, error) {
	rows, err := q.db.Query(ctx, getStatusesForVersions, arg.UUID, arg.Versions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesForVersionsRow
	for rows.Next() {
		var i GetStatusesForVersionsRow
		if err := rows.Scan(
			&i.UUID,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.MetaDocVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemConfig = `-- name: GetSystemConfig :one
SELECT value FROM system_config WHERE name = $1
`

func (q *Queries) GetSystemConfig(ctx context.Context, name string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSystemConfig, name)
	var value []byte
	err := row.Scan(&value)
	return value, err
}

const getTypeConfiguration = `-- name: GetTypeConfiguration :one
SELECT type, bounded_collection, configuration
FROM document_type
WHERE type = $1
`

func (q *Queries) GetTypeConfiguration(ctx context.Context, type_ string) (DocumentType, error) {
	row := q.db.QueryRow(ctx, getTypeConfiguration, type_)
	var i DocumentType
	err := row.Scan(&i.Type, &i.BoundedCollection, &i.Configuration)
	return i, err
}

const getTypeConfigurations = `-- name: GetTypeConfigurations :many
SELECT type, bounded_collection, configuration
FROM document_type
`

func (q *Queries) GetTypeConfigurations(ctx context.Context) ([]DocumentType, error) {
	rows, err := q.db.Query(ctx, getTypeConfigurations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentType
	for rows.Next() {
		var i DocumentType
		if err := rows.Scan(&i.Type, &i.BoundedCollection, &i.Configuration); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypeOfDocument = `-- name: GetTypeOfDocument :one
SELECT type
FROM document
WHERE uuid = $1
`

func (q *Queries) GetTypeOfDocument(ctx context.Context, argUuid uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getTypeOfDocument, argUuid)
	var type_ string
	err := row.Scan(&type_)
	return type_, err
}

const getUpload = `-- name: GetUpload :one
SELECT id, created_at, created_by, meta
FROM upload WHERE id = $1
`

type GetUploadRow struct {
	ID        uuid.UUID
	CreatedAt pgtype.Timestamptz
	CreatedBy string
	Meta      AssetMetadata
}

func (q *Queries) GetUpload(ctx context.Context, id uuid.UUID) (GetUploadRow, error) {
	row := q.db.QueryRow(ctx, getUpload, id)
	var i GetUploadRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Meta,
	)
	return i, err
}

const getVersion = `-- name: GetVersion :one
SELECT created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionParams struct {
	UUID    uuid.UUID
	Version int64
}

type GetVersionRow struct {
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersion(ctx context.Context, arg GetVersionParams) (GetVersionRow, error) {
	row := q.db.QueryRow(ctx, getVersion, arg.UUID, arg.Version)
	var i GetVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.Archived,
	)
	return i, err
}

const getVersionLanguage = `-- name: GetVersionLanguage :one
SELECT language FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionLanguageParams struct {
	UUID    uuid.UUID
	Version int64
}

func (q *Queries) GetVersionLanguage(ctx context.Context, arg GetVersionLanguageParams) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getVersionLanguage, arg.UUID, arg.Version)
	var language pgtype.Text
	err := row.Scan(&language)
	return language, err
}

const getVersions = `-- name: GetVersions :many
SELECT version, created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND ($2::bigint = 0 OR version < $2::bigint)
ORDER BY version DESC
LIMIT $3::bigint
`

type GetVersionsParams struct {
	UUID   uuid.UUID
	Before int64
	Count  int64
}

type GetVersionsRow struct {
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersions(ctx context.Context, arg GetVersionsParams) ([]GetVersionsRow, error) {
	rows, err := q.db.Query(ctx, getVersions, arg.UUID, arg.Before, arg.Count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsRow
	for rows.Next() {
		var i GetVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflowState = `-- name: GetWorkflowState :one
SELECT uuid, type, language, updated, updater_uri, step, checkpoint,
       status_name, status_id, document_version
FROM workflow_state
WHERE uuid = $1
`

type GetWorkflowStateRow struct {
	UUID            uuid.UUID
	Type            string
	Language        string
	Updated         pgtype.Timestamptz
	UpdaterUri      string
	Step            string
	Checkpoint      string
	StatusName      pgtype.Text
	StatusID        pgtype.Int8
	DocumentVersion int64
}

func (q *Queries) GetWorkflowState(ctx context.Context, argUuid uuid.UUID) (GetWorkflowStateRow, error) {
	row := q.db.QueryRow(ctx, getWorkflowState, argUuid)
	var i GetWorkflowStateRow
	err := row.Scan(
		&i.UUID,
		&i.Type,
		&i.Language,
		&i.Updated,
		&i.UpdaterUri,
		&i.Step,
		&i.Checkpoint,
		&i.StatusName,
		&i.StatusID,
		&i.DocumentVersion,
	)
	return i, err
}

const granteesWithPermission = `-- name: GranteesWithPermission :many
SELECT uri
FROM acl
WHERE uuid = $1
      AND $2::text = ANY(permissions)
`

type GranteesWithPermissionParams struct {
	UUID       uuid.UUID
	Permission string
}

func (q *Queries) GranteesWithPermission(ctx context.Context, arg GranteesWithPermissionParams) ([]string, error) {
	rows, err := q.db.Query(ctx, granteesWithPermission, arg.UUID, arg.Permission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uri string
		if err := rows.Scan(&uri); err != nil {
			return nil, err
		}
		items = append(items, uri)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertACLAuditEntry = `-- name: InsertACLAuditEntry :exec
INSERT INTO acl_audit(
       uuid, type, updated,
       updater_uri, state, language,
       system_state
)
SELECT
       $1::uuid, $2, $3::timestamptz,
       $4::text, json_agg(l), $5::text,
       $6
FROM (
       SELECT uri, permissions
       FROM acl
       WHERE uuid = $1::uuid
) AS l
`

type InsertACLAuditEntryParams struct {
	UUID        uuid.UUID
	Type        pgtype.Text
	Updated     pgtype.Timestamptz
	UpdaterUri  string
	Language    string
	SystemState pgtype.Text
}

func (q *Queries) InsertACLAuditEntry(ctx context.Context, arg InsertACLAuditEntryParams) error {
	_, err := q.db.Exec(ctx, insertACLAuditEntry,
		arg.UUID,
		arg.Type,
		arg.Updated,
		arg.UpdaterUri,
		arg.Language,
		arg.SystemState,
	)
	return err
}

const insertDeleteRecord = `-- name: InsertDeleteRecord :one
INSERT INTO delete_record(
       uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, heads, acl, main_doc_type,
       attachments, nonce
) VALUES(
       $1, $2, $3, $4, $5, $6, $7,
       $8, $9, $10, $11, $12, $13,
       $14, $15
) RETURNING id
`

type InsertDeleteRecordParams struct {
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Heads         map[string]int64
	Acl           []ACLEntry
	MainDocType   pgtype.Text
	Attachments   []AttachedObject
	Nonce         uuid.UUID
}

func (q *Queries) InsertDeleteRecord(ctx context.Context, arg InsertDeleteRecordParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertDeleteRecord,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MainDoc,
		arg.Language,
		arg.MetaDocRecord,
		arg.Heads,
		arg.Acl,
		arg.MainDocType,
		arg.Attachments,
		arg.Nonce,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDeletionPlaceholder = `-- name: InsertDeletionPlaceholder :exec
insert into document(
       uuid, uri, type, created, creator_uri, updated, updater_uri,
       current_version, system_state, nonce
) values (
       $1, $2, '', now(), '', now(), '', $3, 'deleting', $4
)
`

type InsertDeletionPlaceholderParams struct {
	UUID     uuid.UUID
	URI      string
	RecordID int64
	Nonce    uuid.UUID
}

func (q *Queries) InsertDeletionPlaceholder(ctx context.Context, arg InsertDeletionPlaceholderParams) error {
	_, err := q.db.Exec(ctx, insertDeletionPlaceholder,
		arg.UUID,
		arg.URI,
		arg.RecordID,
		arg.Nonce,
	)
	return err
}

const insertDocument = `-- name: InsertDocument :exec
INSERT INTO document(
       uuid, uri, type,
       created, creator_uri, updated, updater_uri, current_version,
       main_doc, language, system_state, nonce
) VALUES (
       $1, $2, $3,
       $4, $5, $4, $5, $6,
       $7, $8, $9, $10
)
`

type InsertDocumentParams struct {
	UUID        uuid.UUID
	URI         string
	Type        string
	Created     pgtype.Timestamptz
	CreatorUri  string
	Version     int64
	MainDoc     pgtype.UUID
	Language    pgtype.Text
	SystemState pgtype.Text
	Nonce       uuid.UUID
}

func (q *Queries) InsertDocument(ctx context.Context, arg InsertDocumentParams) error {
	_, err := q.db.Exec(ctx, insertDocument,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Version,
		arg.MainDoc,
		arg.Language,
		arg.SystemState,
		arg.Nonce,
	)
	return err
}

const insertDocumentLock = `-- name: InsertDocumentLock :exec
INSERT INTO document_lock(
  uuid, token, created, expires, uri, app, comment
) VALUES(
  $1, $2, $3, $4, $5, $6, $7
)
`

type InsertDocumentLockParams struct {
	UUID    uuid.UUID
	Token   string
	Created pgtype.Timestamptz
	Expires pgtype.Timestamptz
	URI     pgtype.Text
	App     pgtype.Text
	Comment pgtype.Text
}

func (q *Queries) InsertDocumentLock(ctx context.Context, arg InsertDocumentLockParams) error {
	_, err := q.db.Exec(ctx, insertDocumentLock,
		arg.UUID,
		arg.Token,
		arg.Created,
		arg.Expires,
		arg.URI,
		arg.App,
		arg.Comment,
	)
	return err
}

const insertDocumentStatus = `-- name: InsertDocumentStatus :exec
INSERT INTO document_status(
       uuid, name, id, version, created,
       creator_uri, meta, meta_doc_version
) VALUES (
       $1, $2, $3, $4, $5,
       $6, $7, $8::bigint
)
`

type InsertDocumentStatusParams struct {
	UUID           uuid.UUID
	Name           string
	ID             int64
	Version        int64
	Created        pgtype.Timestamptz
	CreatorUri     string
	Meta           map[string]string
	MetaDocVersion int64
}

func (q *Queries) InsertDocumentStatus(ctx context.Context, arg InsertDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, insertDocumentStatus,
		arg.UUID,
		arg.Name,
		arg.ID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.MetaDocVersion,
	)
	return err
}

const insertIntoEventLog = `-- name: InsertIntoEventLog :exec
INSERT INTO eventlog(
       id, event, uuid, nonce, type, timestamp, updater, version, status, status_id, acl,
       language, old_language, main_doc, system_state, workflow_state, workflow_checkpoint,
       main_doc_type, extra
) VALUES (
       $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
       $12, $13, $14, $15, $16, $17,
       $18, $19
)
`

type InsertIntoEventLogParams struct {
	ID                 int64
	Event              string
	UUID               uuid.UUID
	Nonce              uuid.UUID
	Type               pgtype.Text
	Timestamp          pgtype.Timestamptz
	Updater            pgtype.Text
	Version            pgtype.Int8
	Status             pgtype.Text
	StatusID           pgtype.Int8
	Acl                []byte
	Language           pgtype.Text
	OldLanguage        pgtype.Text
	MainDoc            pgtype.UUID
	SystemState        pgtype.Text
	WorkflowState      pgtype.Text
	WorkflowCheckpoint pgtype.Text
	MainDocType        pgtype.Text
	Extra              *EventlogExtra
}

func (q *Queries) InsertIntoEventLog(ctx context.Context, arg InsertIntoEventLogParams) error {
	_, err := q.db.Exec(ctx, insertIntoEventLog,
		arg.ID,
		arg.Event,
		arg.UUID,
		arg.Nonce,
		arg.Type,
		arg.Timestamp,
		arg.Updater,
		arg.Version,
		arg.Status,
		arg.StatusID,
		arg.Acl,
		arg.Language,
		arg.OldLanguage,
		arg.MainDoc,
		arg.SystemState,
		arg.WorkflowState,
		arg.WorkflowCheckpoint,
		arg.MainDocType,
		arg.Extra,
	)
	return err
}

const insertJobLock = `-- name: InsertJobLock :one
INSERT INTO job_lock(name, holder, touched, iteration)
VALUES ($1, $2, now(), 1)
RETURNING iteration
`

type InsertJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) InsertJobLock(ctx context.Context, arg InsertJobLockParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertJobLock, arg.Name, arg.Holder)
	var iteration int64
	err := row.Scan(&iteration)
	return iteration, err
}

const insertPurgeRequest = `-- name: InsertPurgeRequest :exec
INSERT INTO purge_request(
       uuid, delete_record_id, created, creator
) VALUES(
       $1, $2, $3, $4
)
`

type InsertPurgeRequestParams struct {
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
}

func (q *Queries) InsertPurgeRequest(ctx context.Context, arg InsertPurgeRequestParams) error {
	_, err := q.db.Exec(ctx, insertPurgeRequest,
		arg.UUID,
		arg.DeleteRecordID,
		arg.Created,
		arg.Creator,
	)
	return err
}

const insertRestoreRequest = `-- name: InsertRestoreRequest :exec
INSERT INTO restore_request(
       uuid, delete_record_id, created, creator, spec
) VALUES(
       $1, $2, $3, $4, $5
)
`

type InsertRestoreRequestParams struct {
	UUID           uuid.UUID
	DeleteRecordID int64
	Created        pgtype.Timestamptz
	Creator        string
	Spec           []byte
}

func (q *Queries) InsertRestoreRequest(ctx context.Context, arg InsertRestoreRequestParams) error {
	_, err := q.db.Exec(ctx, insertRestoreRequest,
		arg.UUID,
		arg.DeleteRecordID,
		arg.Created,
		arg.Creator,
		arg.Spec,
	)
	return err
}

const insertSigningKey = `-- name: InsertSigningKey :exec
INSERT INTO signing_keys(kid, spec) VALUES($1, $2)
`

type InsertSigningKeyParams struct {
	Kid  string
	Spec []byte
}

func (q *Queries) InsertSigningKey(ctx context.Context, arg InsertSigningKeyParams) error {
	_, err := q.db.Exec(ctx, insertSigningKey, arg.Kid, arg.Spec)
	return err
}

const listActiveSchemas = `-- name: ListActiveSchemas :many
SELECT a.name, a.version
FROM active_schemas AS a
`

func (q *Queries) ListActiveSchemas(ctx context.Context) ([]ActiveSchema, error) {
	rows, err := q.db.Query(ctx, listActiveSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveSchema
	for rows.Next() {
		var i ActiveSchema
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeleteRecords = `-- name: ListDeleteRecords :many
SELECT id, uuid, uri, type, version, created, creator_uri, meta,
       main_doc, language, meta_doc_record, finalised, purged, attachments
FROM delete_record AS r
WHERE ($1::uuid IS NULL OR r.uuid = $1)
      AND ($2::bigint = 0 OR r.id < $2)
      AND ($3::timestamptz IS NULL OR r.created < $3)
ORDER BY r.id DESC
`

type ListDeleteRecordsParams struct {
	UUID       pgtype.UUID
	BeforeID   int64
	BeforeTime pgtype.Timestamptz
}

type ListDeleteRecordsRow struct {
	ID            int64
	UUID          uuid.UUID
	URI           string
	Type          string
	Version       int64
	Created       pgtype.Timestamptz
	CreatorUri    string
	Meta          []byte
	MainDoc       pgtype.UUID
	Language      pgtype.Text
	MetaDocRecord pgtype.Int8
	Finalised     pgtype.Timestamptz
	Purged        pgtype.Timestamptz
	Attachments   []AttachedObject
}

func (q *Queries) ListDeleteRecords(ctx context.Context, arg ListDeleteRecordsParams) ([]ListDeleteRecordsRow, error) {
	rows, err := q.db.Query(ctx, listDeleteRecords, arg.UUID, arg.BeforeID, arg.BeforeTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeleteRecordsRow
	for rows.Next() {
		var i ListDeleteRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.UUID,
			&i.URI,
			&i.Type,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.MainDoc,
			&i.Language,
			&i.MetaDocRecord,
			&i.Finalised,
			&i.Purged,
			&i.Attachments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockConfigTable = `-- name: LockConfigTable :exec
LOCK TABLE system_config IN ACCESS EXCLUSIVE MODE
`

func (q *Queries) LockConfigTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, lockConfigTable)
	return err
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const pingJobLock = `-- name: PingJobLock :execrows
UPDATE job_lock
SET touched = now(),
    iteration = iteration + 1
WHERE name = $1
      AND holder = $2
      AND iteration = $3
`

type PingJobLockParams struct {
	Name      string
	Holder    string
	Iteration int64
}

func (q *Queries) PingJobLock(ctx context.Context, arg PingJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, pingJobLock, arg.Name, arg.Holder, arg.Iteration)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const purgeDeleteRecordDetails = `-- name: PurgeDeleteRecordDetails :exec
UPDATE delete_record SET
       meta = NULL, acl = NULL, heads = NULL, version = 0,
       language = NULL, 
       purged = $1
WHERE id = $2
`

type PurgeDeleteRecordDetailsParams struct {
	PurgedTime pgtype.Timestamptz
	ID         int64
}

func (q *Queries) PurgeDeleteRecordDetails(ctx context.Context, arg PurgeDeleteRecordDetailsParams) error {
	_, err := q.db.Exec(ctx, purgeDeleteRecordDetails, arg.PurgedTime, arg.ID)
	return err
}

const readEventOutbox = `-- name: ReadEventOutbox :many
SELECT id, event FROM event_outbox_item
ORDER BY id ASC
LIMIT $1::bigint
`

func (q *Queries) ReadEventOutbox(ctx context.Context, count int64) ([]EventOutboxItem, error) {
	rows, err := q.db.Query(ctx, readEventOutbox, count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventOutboxItem
	for rows.Next() {
		var i EventOutboxItem
		if err := rows.Scan(&i.ID, &i.Event); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readForRestore = `-- name: ReadForRestore :one
SELECT system_state FROM document
WHERE uuid = $1
`

func (q *Queries) ReadForRestore(ctx context.Context, argUuid uuid.UUID) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, readForRestore, argUuid)
	var system_state pgtype.Text
	err := row.Scan(&system_state)
	return system_state, err
}

const registerMetaType = `-- name: RegisterMetaType :exec
INSERT INTO meta_type(
       meta_type, exclusive_for_meta
) VALUES (
       $1, $2
) ON CONFLICT (meta_type) DO UPDATE SET
  exclusive_for_meta = $2
`

type RegisterMetaTypeParams struct {
	MetaType         string
	ExclusiveForMeta bool
}

func (q *Queries) RegisterMetaType(ctx context.Context, arg RegisterMetaTypeParams) error {
	_, err := q.db.Exec(ctx, registerMetaType, arg.MetaType, arg.ExclusiveForMeta)
	return err
}

const registerMetaTypeUse = `-- name: RegisterMetaTypeUse :exec
INSERT INTO meta_type_use(
       main_type, meta_type
) VALUES (
       $1, $2
)
`

type RegisterMetaTypeUseParams struct {
	MainType string
	MetaType string
}

func (q *Queries) RegisterMetaTypeUse(ctx context.Context, arg RegisterMetaTypeUseParams) error {
	_, err := q.db.Exec(ctx, registerMetaTypeUse, arg.MainType, arg.MetaType)
	return err
}

const registerMetricKind = `-- name: RegisterMetricKind :exec
INSERT INTO metric_kind(name, aggregation)
VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE
   SET aggregation = excluded.aggregation
`

type RegisterMetricKindParams struct {
	Name        string
	Aggregation int16
}

func (q *Queries) RegisterMetricKind(ctx context.Context, arg RegisterMetricKindParams) error {
	_, err := q.db.Exec(ctx, registerMetricKind, arg.Name, arg.Aggregation)
	return err
}

const registerOrIncrementMetric = `-- name: RegisterOrIncrementMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = metric.value + $4
`

type RegisterOrIncrementMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrIncrementMetric(ctx context.Context, arg RegisterOrIncrementMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrIncrementMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerOrReplaceMetric = `-- name: RegisterOrReplaceMetric :exec
INSERT INTO metric(uuid, kind, label, value)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT metric_pkey DO UPDATE 
SET value = $4
`

type RegisterOrReplaceMetricParams struct {
	UUID  uuid.UUID
	Kind  string
	Label string
	Value int64
}

func (q *Queries) RegisterOrReplaceMetric(ctx context.Context, arg RegisterOrReplaceMetricParams) error {
	_, err := q.db.Exec(ctx, registerOrReplaceMetric,
		arg.UUID,
		arg.Kind,
		arg.Label,
		arg.Value,
	)
	return err
}

const registerSchema = `-- name: RegisterSchema :exec
INSERT INTO document_schema(name, version, spec)
VALUES ($1, $2, $3)
`

type RegisterSchemaParams struct {
	Name    string
	Version string
	Spec    []byte
}

func (q *Queries) RegisterSchema(ctx context.Context, arg RegisterSchemaParams) error {
	_, err := q.db.Exec(ctx, registerSchema, arg.Name, arg.Version, arg.Spec)
	return err
}

const releaseJobLock = `-- name: ReleaseJobLock :execrows
DELETE FROM job_lock
WHERE name = $1
      AND holder = $2
`

type ReleaseJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) ReleaseJobLock(ctx context.Context, arg ReleaseJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseJobLock, arg.Name, arg.Holder)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const selectBoundedDocumentsWithType = `-- name: SelectBoundedDocumentsWithType :many
SELECT d.uuid, d.current_version, d.language
FROM document_type AS dt
     INNER JOIN document AS d
           ON d.type = dt.type
           AND ($1::text IS NULL OR d.language = $1)
WHERE dt.type = $2
      AND (COALESCE(cardinality($3::text[]), 0) = 0 OR d.labels @> $3)
      AND dt.bounded_collection
`

type SelectBoundedDocumentsWithTypeParams struct {
	Language pgtype.Text
	Type     string
	Labels   []string
}

type SelectBoundedDocumentsWithTypeRow struct {
	UUID           uuid.UUID
	CurrentVersion int64
	Language       pgtype.Text
}

func (q *Queries) SelectBoundedDocumentsWithType(ctx context.Context, arg SelectBoundedDocumentsWithTypeParams) ([]SelectBoundedDocumentsWithTypeRow, error) {
	rows, err := q.db.Query(ctx, selectBoundedDocumentsWithType, arg.Language, arg.Type, arg.Labels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectBoundedDocumentsWithTypeRow
	for rows.Next() {
		var i SelectBoundedDocumentsWithTypeRow
		if err := rows.Scan(&i.UUID, &i.CurrentVersion, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectDocumentsInTimeRange = `-- name: SelectDocumentsInTimeRange :many
SELECT d.uuid, d.current_version, d.language
FROM document AS d
WHERE d.time && $1::tstzrange
      AND (COALESCE(cardinality($2::text[]), 0) = 0 OR d.labels @> $2)
      AND d.type = $3
`

type SelectDocumentsInTimeRangeParams struct {
	Range  pgtype.Range[pgtype.Timestamptz]
	Labels []string
	Type   string
}

type SelectDocumentsInTimeRangeRow struct {
	UUID           uuid.UUID
	CurrentVersion int64
	Language       pgtype.Text
}

func (q *Queries) SelectDocumentsInTimeRange(ctx context.Context, arg SelectDocumentsInTimeRangeParams) ([]SelectDocumentsInTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, selectDocumentsInTimeRange, arg.Range, arg.Labels, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectDocumentsInTimeRangeRow
	for rows.Next() {
		var i SelectDocumentsInTimeRangeRow
		if err := rows.Scan(&i.UUID, &i.CurrentVersion, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCurrentAttachedObject = `-- name: SetCurrentAttachedObject :exec
INSERT INTO attached_object_current(
       document, name, version, deleted
) VALUES (
       $1, $2, $3, $4
) ON CONFLICT (document, name) DO UPDATE SET
       version = excluded.version,
       deleted = excluded.deleted
`

type SetCurrentAttachedObjectParams struct {
	Document uuid.UUID
	Name     string
	Version  int64
	Deleted  bool
}

func (q *Queries) SetCurrentAttachedObject(ctx context.Context, arg SetCurrentAttachedObjectParams) error {
	_, err := q.db.Exec(ctx, setCurrentAttachedObject,
		arg.Document,
		arg.Name,
		arg.Version,
		arg.Deleted,
	)
	return err
}

const setDocumentStatusAsArchived = `-- name: SetDocumentStatusAsArchived :exec
UPDATE document_status
SET archived = true, signature = $1::text
WHERE uuid = $2 AND name = $3 AND id = $4
`

type SetDocumentStatusAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	Name      string
	ID        int64
}

func (q *Queries) SetDocumentStatusAsArchived(ctx context.Context, arg SetDocumentStatusAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentStatusAsArchived,
		arg.Signature,
		arg.UUID,
		arg.Name,
		arg.ID,
	)
	return err
}

const setDocumentVersionAsArchived = `-- name: SetDocumentVersionAsArchived :exec
UPDATE document_version
SET archived = true, signature = $1::text
WHERE uuid = $2 AND version = $3
`

type SetDocumentVersionAsArchivedParams struct {
	Signature string
	UUID      uuid.UUID
	Version   int64
}

func (q *Queries) SetDocumentVersionAsArchived(ctx context.Context, arg SetDocumentVersionAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentVersionAsArchived, arg.Signature, arg.UUID, arg.Version)
	return err
}

const setDocumentWorkflow = `-- name: SetDocumentWorkflow :exec
INSERT INTO workflow(
       type, updated, updater_uri, configuration
) VALUES (
       $1, $2, $3, $4
) ON CONFLICT(type) DO UPDATE SET
  updated = excluded.updated,
  updater_uri = excluded.updater_uri,
  configuration = excluded.configuration
`

type SetDocumentWorkflowParams struct {
	Type          string
	Updated       pgtype.Timestamptz
	UpdaterUri    string
	Configuration []byte
}

func (q *Queries) SetDocumentWorkflow(ctx context.Context, arg SetDocumentWorkflowParams) error {
	_, err := q.db.Exec(ctx, setDocumentWorkflow,
		arg.Type,
		arg.Updated,
		arg.UpdaterUri,
		arg.Configuration,
	)
	return err
}

const setEventlogArchiver = `-- name: SetEventlogArchiver :exec
INSERT INTO eventlog_archiver(size, position, last_signature)
       VALUES ($1, $2, $3)
ON CONFLICT (size) DO UPDATE
   SET position = $2,
       last_signature = $3
`

type SetEventlogArchiverParams struct {
	Size      int64
	Position  int64
	Signature string
}

func (q *Queries) SetEventlogArchiver(ctx context.Context, arg SetEventlogArchiverParams) error {
	_, err := q.db.Exec(ctx, setEventlogArchiver, arg.Size, arg.Position, arg.Signature)
	return err
}

const setEventlogItemAsArchived = `-- name: SetEventlogItemAsArchived :exec
UPDATE eventlog
SET signature = $1
WHERE id = $2
`

type SetEventlogItemAsArchivedParams struct {
	Signature pgtype.Text
	ID        int64
}

func (q *Queries) SetEventlogItemAsArchived(ctx context.Context, arg SetEventlogItemAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setEventlogItemAsArchived, arg.Signature, arg.ID)
	return err
}

const setPlanningAssignee = `-- name: SetPlanningAssignee :exec
INSERT INTO planning_assignee(
       assignment, assignee, version, role
) VALUES (
       $1, $2, $3, $4
)
ON CONFLICT ON CONSTRAINT planning_assignee_pkey DO UPDATE
SET version = $3, role = $4
`

type SetPlanningAssigneeParams struct {
	Assignment uuid.UUID
	Assignee   uuid.UUID
	Version    int64
	Role       string
}

func (q *Queries) SetPlanningAssignee(ctx context.Context, arg SetPlanningAssigneeParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignee,
		arg.Assignment,
		arg.Assignee,
		arg.Version,
		arg.Role,
	)
	return err
}

const setPlanningAssignment = `-- name: SetPlanningAssignment :exec
INSERT INTO planning_assignment(
       uuid, version, planning_item, status, publish, publish_slot,
       starts, ends, start_date, end_date, full_day, public, kind, description,
       timezone, timerange
) VALUES (
       $1, $2, $3, $4, $5, $6,
       $7, $8, $9, $10, $11, $12, $13,
       $14, $15, $16
)
ON CONFLICT ON CONSTRAINT planning_assignment_pkey DO UPDATE
SET
   version = excluded.version,
   planning_item = excluded.planning_item,
   status = excluded.status,
   publish = excluded.publish,
   publish_slot = excluded.publish_slot,
   starts = excluded.starts,
   ends = excluded.ends,
   start_date = excluded.start_date,
   end_date = excluded.end_date,
   full_day = excluded.full_day,
   public = excluded.public,
   kind = excluded.kind,
   description = excluded.description,
   timezone = excluded.timezone,
   timerange = excluded.timerange
`

type SetPlanningAssignmentParams struct {
	UUID         uuid.UUID
	Version      int64
	PlanningItem uuid.UUID
	Status       pgtype.Text
	Publish      pgtype.Timestamptz
	PublishSlot  pgtype.Int2
	Starts       pgtype.Timestamptz
	Ends         pgtype.Timestamptz
	StartDate    pgtype.Date
	EndDate      pgtype.Date
	FullDay      bool
	Public       bool
	Kind         []string
	Description  string
	Timezone     pgtype.Text
	Timerange    pgtype.Range[pgtype.Timestamptz]
}

func (q *Queries) SetPlanningAssignment(ctx context.Context, arg SetPlanningAssignmentParams) error {
	_, err := q.db.Exec(ctx, setPlanningAssignment,
		arg.UUID,
		arg.Version,
		arg.PlanningItem,
		arg.Status,
		arg.Publish,
		arg.PublishSlot,
		arg.Starts,
		arg.Ends,
		arg.StartDate,
		arg.EndDate,
		arg.FullDay,
		arg.Public,
		arg.Kind,
		arg.Description,
		arg.Timezone,
		arg.Timerange,
	)
	return err
}

const setPlanningItem = `-- name: SetPlanningItem :exec
INSERT INTO planning_item(
        uuid, version, title, description, tentative,
        start_date, end_date, priority, event
) VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9
)
ON CONFLICT ON CONSTRAINT planning_item_pkey DO UPDATE
SET
   version = $2, title = $3, description = $4,
   public = $10, tentative = $5, start_date = $6,
   end_date = $7, priority = $8, event = $9
`

type SetPlanningItemParams struct {
	UUID        uuid.UUID
	Version     int64
	Title       string
	Description string
	Tentative   bool
	StartDate   pgtype.Date
	EndDate     pgtype.Date
	Priority    pgtype.Int2
	Event       pgtype.UUID
	Public      pgtype.Bool
}

func (q *Queries) SetPlanningItem(ctx context.Context, arg SetPlanningItemParams) error {
	_, err := q.db.Exec(ctx, setPlanningItem,
		arg.UUID,
		arg.Version,
		arg.Title,
		arg.Description,
		arg.Tentative,
		arg.StartDate,
		arg.EndDate,
		arg.Priority,
		arg.Event,
		arg.Public,
	)
	return err
}

const setPlanningItemDeliverable = `-- name: SetPlanningItemDeliverable :exec
INSERT INTO planning_deliverable(
       assignment, document, version
) VALUES(
       $1, $2, $3
)
ON CONFLICT ON CONSTRAINT planning_deliverable_pkey DO UPDATE
SET
   version = $3
`

type SetPlanningItemDeliverableParams struct {
	Assignment uuid.UUID
	Document   uuid.UUID
	Version    int64
}

func (q *Queries) SetPlanningItemDeliverable(ctx context.Context, arg SetPlanningItemDeliverableParams) error {
	_, err := q.db.Exec(ctx, setPlanningItemDeliverable, arg.Assignment, arg.Document, arg.Version)
	return err
}

const setSystemConfig = `-- name: SetSystemConfig :exec
INSERT INTO system_config(name, value)
       VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE SET
   value = excluded.value
`

type SetSystemConfigParams struct {
	Name  string
	Value []byte
}

func (q *Queries) SetSystemConfig(ctx context.Context, arg SetSystemConfigParams) error {
	_, err := q.db.Exec(ctx, setSystemConfig, arg.Name, arg.Value)
	return err
}

const setTypeConfiguration = `-- name: SetTypeConfiguration :exec
INSERT INTO document_type(type, bounded_collection, configuration)
VALUES ($1, $2, $3)
ON CONFLICT (type) DO UPDATE
   SET bounded_collection = excluded.bounded_collection,
       configuration = excluded.configuration
`

type SetTypeConfigurationParams struct {
	Type              string
	BoundedCollection bool
	Configuration     TypeConfiguration
}

func (q *Queries) SetTypeConfiguration(ctx context.Context, arg SetTypeConfigurationParams) error {
	_, err := q.db.Exec(ctx, setTypeConfiguration, arg.Type, arg.BoundedCollection, arg.Configuration)
	return err
}

const stealJobLock = `-- name: StealJobLock :execrows
UPDATE job_lock
SET holder = $1,
    touched = now(),
    iteration = iteration + 1
WHERE name = $2
      AND holder = $3
      AND iteration = $4
`

type StealJobLockParams struct {
	NewHolder      string
	Name           string
	PreviousHolder string
	Iteration      int64
}

func (q *Queries) StealJobLock(ctx context.Context, arg StealJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, stealJobLock,
		arg.NewHolder,
		arg.Name,
		arg.PreviousHolder,
		arg.Iteration,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateDeprecation = `-- name: UpdateDeprecation :exec
INSERT INTO deprecation(label, enforced)
VALUES($1, $2)
ON CONFLICT(label) DO UPDATE SET
   enforced = $2
`

type UpdateDeprecationParams struct {
	Label    string
	Enforced bool
}

func (q *Queries) UpdateDeprecation(ctx context.Context, arg UpdateDeprecationParams) error {
	_, err := q.db.Exec(ctx, updateDeprecation, arg.Label, arg.Enforced)
	return err
}

const updateDocumentLock = `-- name: UpdateDocumentLock :exec
UPDATE document_lock
SET expires = $1
WHERE uuid = $2
`

type UpdateDocumentLockParams struct {
	Expires pgtype.Timestamptz
	UUID    uuid.UUID
}

func (q *Queries) UpdateDocumentLock(ctx context.Context, arg UpdateDocumentLockParams) error {
	_, err := q.db.Exec(ctx, updateDocumentLock, arg.Expires, arg.UUID)
	return err
}

const updateDocumentTime = `-- name: UpdateDocumentTime :exec
UPDATE document
SET time = $1
WHERE uuid = $2
`

type UpdateDocumentTimeParams struct {
	Time pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	UUID uuid.UUID
}

func (q *Queries) UpdateDocumentTime(ctx context.Context, arg UpdateDocumentTimeParams) error {
	_, err := q.db.Exec(ctx, updateDocumentTime, arg.Time, arg.UUID)
	return err
}

const updateDocumentUnarchivedCount = `-- name: UpdateDocumentUnarchivedCount :one
INSERT INTO document_archive_counter AS dac (uuid, unarchived)
VALUES ($1, GREATEST(0, $2::int))
ON CONFLICT (uuid) DO UPDATE
   SET unarchived = GREATEST(0, dac.unarchived + $2::int)
RETURNING unarchived
`

type UpdateDocumentUnarchivedCountParams struct {
	UUID  uuid.UUID
	Delta int32
}

func (q *Queries) UpdateDocumentUnarchivedCount(ctx context.Context, arg UpdateDocumentUnarchivedCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateDocumentUnarchivedCount, arg.UUID, arg.Delta)
	var unarchived int32
	err := row.Scan(&unarchived)
	return unarchived, err
}

const updateEventsinkPosition = `-- name: UpdateEventsinkPosition :exec
UPDATE eventsink SET position = $1 WHERE name = $2
`

type UpdateEventsinkPositionParams struct {
	Position int64
	Name     string
}

func (q *Queries) UpdateEventsinkPosition(ctx context.Context, arg UpdateEventsinkPositionParams) error {
	_, err := q.db.Exec(ctx, updateEventsinkPosition, arg.Position, arg.Name)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
INSERT INTO status(type, name, disabled)
VALUES($1, $2, $3)
ON CONFLICT(type, name) DO UPDATE SET
   disabled = $3
`

type UpdateStatusParams struct {
	Type     string
	Name     string
	Disabled bool
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Type, arg.Name, arg.Disabled)
	return err
}

const updateStatusRule = `-- name: UpdateStatusRule :exec
INSERT INTO status_rule(
       type, name, description, access_rule, applies_to, expression
) VALUES(
       $1, $2, $3, $4, $5, $6
) ON CONFLICT(type, name)
  DO UPDATE SET
     description = $3, access_rule = $4,
     applies_to = $5, expression = $6
`

type UpdateStatusRuleParams struct {
	Type        string
	Name        string
	Description string
	AccessRule  bool
	AppliesTo   []string
	Expression  string
}

func (q *Queries) UpdateStatusRule(ctx context.Context, arg UpdateStatusRuleParams) error {
	_, err := q.db.Exec(ctx, updateStatusRule,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.AccessRule,
		arg.AppliesTo,
		arg.Expression,
	)
	return err
}

const upsertDocument = `-- name: UpsertDocument :exec
INSERT INTO document(
       uuid, uri, type,
       created, creator_uri, updated, updater_uri, current_version,
       main_doc, language, main_doc_type, nonce, time, labels
) VALUES (
       $1, $2, $3,
       $4, $5, $4, $5, $6,
       $7, $8, $9, $10, $11, $12
) ON CONFLICT (uuid) DO UPDATE
     SET uri = excluded.uri,
         updated = excluded.created,
         updater_uri = excluded.creator_uri,
         current_version = excluded.current_version,
         language = excluded.language,
         time = COALESCE(excluded.time, document.time),
         labels = COALESCE(excluded.labels, document.labels)
`

type UpsertDocumentParams struct {
	UUID        uuid.UUID
	URI         string
	Type        string
	Created     pgtype.Timestamptz
	CreatorUri  string
	Version     int64
	MainDoc     pgtype.UUID
	Language    pgtype.Text
	MainDocType pgtype.Text
	Nonce       uuid.UUID
	Time        pgtype.Multirange[pgtype.Range[pgtype.Timestamptz]]
	Labels      []string
}

func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.UUID,
		arg.URI,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Version,
		arg.MainDoc,
		arg.Language,
		arg.MainDocType,
		arg.Nonce,
		arg.Time,
		arg.Labels,
	)
	return err
}
