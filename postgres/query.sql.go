// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireTXLock = `-- name: AcquireTXLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireTXLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, acquireTXLock, id)
	return err
}

const activateSchema = `-- name: ActivateSchema :exec
INSERT INTO active_schemas(name, version)
VALUES ($1, $2)
       ON CONFLICT(name) DO UPDATE SET
          version = $2
`

type ActivateSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) ActivateSchema(ctx context.Context, arg ActivateSchemaParams) error {
	_, err := q.db.Exec(ctx, activateSchema, arg.Name, arg.Version)
	return err
}

const checkPermission = `-- name: CheckPermission :one
SELECT (acl.uri IS NOT NULL) = true AS has_access
FROM document AS d
     LEFT JOIN acl
          ON acl.uuid = d.uuid AND acl.uri = ANY($1::text[])
          AND $2::text = ANY(permissions)
WHERE d.uuid = $3
`

type CheckPermissionParams struct {
	Uri        []string
	Permission string
	Uuid       uuid.UUID
}

func (q *Queries) CheckPermission(ctx context.Context, arg CheckPermissionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPermission, arg.Uri, arg.Permission, arg.Uuid)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const configureEventsink = `-- name: ConfigureEventsink :exec
INSERT INTO eventsink(name, configuration) VALUES($1, $2)
ON CONFLICT (name) DO UPDATE SET
   configuration = $2
`

type ConfigureEventsinkParams struct {
	Name   string
	Config []byte
}

func (q *Queries) ConfigureEventsink(ctx context.Context, arg ConfigureEventsinkParams) error {
	_, err := q.db.Exec(ctx, configureEventsink, arg.Name, arg.Config)
	return err
}

const createStatus = `-- name: CreateStatus :exec
SELECT create_status(
       $1::uuid, $2::varchar(32), $3::bigint, $4::bigint,
       $5::text, $6::timestamptz, $7::text, $8::jsonb
)
`

type CreateStatusParams struct {
	Uuid       uuid.UUID
	Name       string
	ID         int64
	Version    int64
	Type       string
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) CreateStatus(ctx context.Context, arg CreateStatusParams) error {
	_, err := q.db.Exec(ctx, createStatus,
		arg.Uuid,
		arg.Name,
		arg.ID,
		arg.Version,
		arg.Type,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
	)
	return err
}

const createVersion = `-- name: CreateVersion :exec
SELECT create_version(
       $1::uuid, $2::bigint, $3::timestamptz,
       $4::text, $5::jsonb, $6::jsonb
)
`

type CreateVersionParams struct {
	Uuid         uuid.UUID
	Version      int64
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
}

func (q *Queries) CreateVersion(ctx context.Context, arg CreateVersionParams) error {
	_, err := q.db.Exec(ctx, createVersion,
		arg.Uuid,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.DocumentData,
	)
	return err
}

const deactivateSchema = `-- name: DeactivateSchema :exec
DELETE FROM active_schemas
WHERE name = $1
`

func (q *Queries) DeactivateSchema(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deactivateSchema, name)
	return err
}

const deleteDocument = `-- name: DeleteDocument :exec
SELECT delete_document(
       $1::uuid, $2::text, $3::bigint
)
`

type DeleteDocumentParams struct {
	Uuid     uuid.UUID
	Uri      string
	RecordID int64
}

func (q *Queries) DeleteDocument(ctx context.Context, arg DeleteDocumentParams) error {
	_, err := q.db.Exec(ctx, deleteDocument, arg.Uuid, arg.Uri, arg.RecordID)
	return err
}

const deleteStatusRule = `-- name: DeleteStatusRule :exec
DELETE FROM status_rule WHERE name = $1
`

func (q *Queries) DeleteStatusRule(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteStatusRule, name)
	return err
}

const dropACL = `-- name: DropACL :exec
DELETE FROM acl WHERE uuid = $1 AND uri = $2
`

type DropACLParams struct {
	Uuid uuid.UUID
	Uri  string
}

func (q *Queries) DropACL(ctx context.Context, arg DropACLParams) error {
	_, err := q.db.Exec(ctx, dropACL, arg.Uuid, arg.Uri)
	return err
}

const finaliseDelete = `-- name: FinaliseDelete :execrows
DELETE FROM document
WHERE uuid = $1 AND deleting = true
`

func (q *Queries) FinaliseDelete(ctx context.Context, uuid uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, finaliseDelete, uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveSchema = `-- name: GetActiveSchema :one
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
WHERE a.name = $1
`

func (q *Queries) GetActiveSchema(ctx context.Context, name string) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getActiveSchema, name)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getActiveSchemas = `-- name: GetActiveSchemas :many
SELECT s.name, s.version, s.spec
FROM active_schemas AS a
     INNER JOIN document_schema AS s
           ON s.name = a.name AND s.version = a.version
`

func (q *Queries) GetActiveSchemas(ctx context.Context) ([]DocumentSchema, error) {
	rows, err := q.db.Query(ctx, getActiveSchemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentSchema
	for rows.Next() {
		var i DocumentSchema
		if err := rows.Scan(&i.Name, &i.Version, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStatuses = `-- name: GetActiveStatuses :many
SELECT name
FROM status
WHERE disabled = false
`

func (q *Queries) GetActiveStatuses(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getActiveStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

func (q *Queries) GetDocumentACL(ctx context.Context, uuid uuid.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.Uuid, &i.Uri, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentData = `-- name: GetDocumentData :one
SELECT v.document_data
FROM document as d
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid And v.version = d.current_version
WHERE d.uuid = $1
`

func (q *Queries) GetDocumentData(ctx context.Context, uuid uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getDocumentData, uuid)
	var document_data []byte
	err := row.Scan(&document_data)
	return document_data, err
}

const getDocumentForDeletion = `-- name: GetDocumentForDeletion :one
SELECT uuid, current_version AS delete_record_id FROM document
WHERE deleting = true
ORDER BY created
FOR UPDATE SKIP LOCKED
LIMIT 1
`

type GetDocumentForDeletionRow struct {
	Uuid           uuid.UUID
	DeleteRecordID int64
}

func (q *Queries) GetDocumentForDeletion(ctx context.Context) (GetDocumentForDeletionRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForDeletion)
	var i GetDocumentForDeletionRow
	err := row.Scan(&i.Uuid, &i.DeleteRecordID)
	return i, err
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
SELECT uri, type, current_version, deleting FROM document
WHERE uuid = $1
FOR UPDATE
`

type GetDocumentForUpdateRow struct {
	Uri            string
	Type           string
	CurrentVersion int64
	Deleting       bool
}

func (q *Queries) GetDocumentForUpdate(ctx context.Context, uuid uuid.UUID) (GetDocumentForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, uuid)
	var i GetDocumentForUpdateRow
	err := row.Scan(
		&i.Uri,
		&i.Type,
		&i.CurrentVersion,
		&i.Deleting,
	)
	return i, err
}

const getDocumentHeads = `-- name: GetDocumentHeads :many
SELECT name, current_id
FROM status_heads
WHERE uuid = $1
`

type GetDocumentHeadsRow struct {
	Name      string
	CurrentID int64
}

func (q *Queries) GetDocumentHeads(ctx context.Context, uuid uuid.UUID) ([]GetDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getDocumentHeads, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentHeadsRow
	for rows.Next() {
		var i GetDocumentHeadsRow
		if err := rows.Scan(&i.Name, &i.CurrentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentInfo = `-- name: GetDocumentInfo :one
SELECT
        uuid, uri, created, creator_uri, updated, updater_uri, current_version,
        deleting
FROM document
WHERE uuid = $1
`

type GetDocumentInfoRow struct {
	Uuid           uuid.UUID
	Uri            string
	Created        pgtype.Timestamptz
	CreatorUri     string
	Updated        pgtype.Timestamptz
	UpdaterUri     string
	CurrentVersion int64
	Deleting       bool
}

func (q *Queries) GetDocumentInfo(ctx context.Context, uuid uuid.UUID) (GetDocumentInfoRow, error) {
	row := q.db.QueryRow(ctx, getDocumentInfo, uuid)
	var i GetDocumentInfoRow
	err := row.Scan(
		&i.Uuid,
		&i.Uri,
		&i.Created,
		&i.CreatorUri,
		&i.Updated,
		&i.UpdaterUri,
		&i.CurrentVersion,
		&i.Deleting,
	)
	return i, err
}

const getDocumentStatusForArchiving = `-- name: GetDocumentStatusForArchiving :one
SELECT
        s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
        p.signature AS parent_signature, v.signature AS version_signature
FROM document_status AS s
     INNER JOIN document_version AS v
           ON v.uuid = s.uuid
              AND v.version = s.version
              AND v.signature IS NOT NULL
     LEFT JOIN document_status AS p
          ON p.uuid = s.uuid AND p.name = s.name AND p.id = s.id-1
WHERE s.archived = false
AND (s.id = 1 OR p.archived = true)
ORDER BY s.created
FOR UPDATE OF s SKIP LOCKED
LIMIT 1
`

type GetDocumentStatusForArchivingRow struct {
	Uuid             uuid.UUID
	Name             string
	ID               int64
	Version          int64
	Created          pgtype.Timestamptz
	CreatorUri       string
	Meta             []byte
	ParentSignature  pgtype.Text
	VersionSignature pgtype.Text
}

func (q *Queries) GetDocumentStatusForArchiving(ctx context.Context) (GetDocumentStatusForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentStatusForArchiving)
	var i GetDocumentStatusForArchivingRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.ID,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.ParentSignature,
		&i.VersionSignature,
	)
	return i, err
}

const getDocumentUnarchivedCount = `-- name: GetDocumentUnarchivedCount :one
SELECT SUM(num) FROM (
       SELECT COUNT(*) as num
              FROM document_status AS s
              WHERE s.uuid = $1 AND s.archived = false
       UNION
       SELECT COUNT(*) as num
              FROM document_version AS v
              WHERE v.uuid = $1 AND v.archived = false
) AS unarchived
`

func (q *Queries) GetDocumentUnarchivedCount(ctx context.Context, uuid uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getDocumentUnarchivedCount, uuid)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const getDocumentVersionData = `-- name: GetDocumentVersionData :one
SELECT document_data
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetDocumentVersionDataParams struct {
	Uuid    uuid.UUID
	Version int64
}

func (q *Queries) GetDocumentVersionData(ctx context.Context, arg GetDocumentVersionDataParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionData, arg.Uuid, arg.Version)
	var document_data []byte
	err := row.Scan(&document_data)
	return document_data, err
}

const getDocumentVersionForArchiving = `-- name: GetDocumentVersionForArchiving :one
SELECT
        v.uuid, v.version, v.created, v.creator_uri, v.meta, v.document_data,
        p.signature AS parent_signature
FROM document_version AS v
     LEFT JOIN document_version AS p
          ON p.uuid = v.uuid AND p.version = v.version-1
WHERE v.archived = false
AND (v.version = 1 OR p.archived = true)
ORDER BY v.created
FOR UPDATE OF v SKIP LOCKED
LIMIT 1
`

type GetDocumentVersionForArchivingRow struct {
	Uuid            uuid.UUID
	Version         int64
	Created         pgtype.Timestamptz
	CreatorUri      string
	Meta            []byte
	DocumentData    []byte
	ParentSignature pgtype.Text
}

func (q *Queries) GetDocumentVersionForArchiving(ctx context.Context) (GetDocumentVersionForArchivingRow, error) {
	row := q.db.QueryRow(ctx, getDocumentVersionForArchiving)
	var i GetDocumentVersionForArchivingRow
	err := row.Scan(
		&i.Uuid,
		&i.Version,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.ParentSignature,
	)
	return i, err
}

const getDueReport = `-- name: GetDueReport :one
SELECT name, enabled, next_execution, spec
FROM report
WHERE enabled AND next_execution < now()
FOR UPDATE SKIP LOCKED
LIMIT 1
`

func (q *Queries) GetDueReport(ctx context.Context) (Report, error) {
	row := q.db.QueryRow(ctx, getDueReport)
	var i Report
	err := row.Scan(
		&i.Name,
		&i.Enabled,
		&i.NextExecution,
		&i.Spec,
	)
	return i, err
}

const getEventlog = `-- name: GetEventlog :many
SELECT id, event, uuid, timestamp, updater, type, version, status, status_id, acl
FROM eventlog
WHERE id > $1
ORDER BY id ASC
LIMIT $2
`

type GetEventlogParams struct {
	After    int64
	RowLimit int32
}

type GetEventlogRow struct {
	ID        int64
	Event     string
	Uuid      uuid.UUID
	Timestamp pgtype.Timestamptz
	Updater   pgtype.Text
	Type      pgtype.Text
	Version   pgtype.Int8
	Status    pgtype.Text
	StatusID  pgtype.Int8
	Acl       []byte
}

func (q *Queries) GetEventlog(ctx context.Context, arg GetEventlogParams) ([]GetEventlogRow, error) {
	rows, err := q.db.Query(ctx, getEventlog, arg.After, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventlogRow
	for rows.Next() {
		var i GetEventlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Event,
			&i.Uuid,
			&i.Timestamp,
			&i.Updater,
			&i.Type,
			&i.Version,
			&i.Status,
			&i.StatusID,
			&i.Acl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsinkPosition = `-- name: GetEventsinkPosition :one
SELECT position FROM eventsink WHERE name = $1
`

func (q *Queries) GetEventsinkPosition(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getEventsinkPosition, name)
	var position int64
	err := row.Scan(&position)
	return position, err
}

const getFullDocumentHeads = `-- name: GetFullDocumentHeads :many
SELECT s.uuid, s.name, s.id, s.version, s.created, s.creator_uri, s.meta,
       s.archived, s.signature
FROM status_heads AS h
     INNER JOIN document_status AS s ON
           s.uuid = h.uuid AND s.name = h.name AND s.id = h.current_id
WHERE h.uuid = $1
`

func (q *Queries) GetFullDocumentHeads(ctx context.Context, uuid uuid.UUID) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getFullDocumentHeads, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullVersion = `-- name: GetFullVersion :one
SELECT created, creator_uri, meta, document_data, archived, signature
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetFullVersionParams struct {
	Uuid    uuid.UUID
	Version int64
}

type GetFullVersionRow struct {
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
	Archived     bool
	Signature    pgtype.Text
}

func (q *Queries) GetFullVersion(ctx context.Context, arg GetFullVersionParams) (GetFullVersionRow, error) {
	row := q.db.QueryRow(ctx, getFullVersion, arg.Uuid, arg.Version)
	var i GetFullVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.Archived,
		&i.Signature,
	)
	return i, err
}

const getJobLock = `-- name: GetJobLock :one
SELECT holder, touched, iteration
FROM job_lock
WHERE name = $1
FOR UPDATE
`

type GetJobLockRow struct {
	Holder    string
	Touched   pgtype.Timestamptz
	Iteration int64
}

func (q *Queries) GetJobLock(ctx context.Context, name string) (GetJobLockRow, error) {
	row := q.db.QueryRow(ctx, getJobLock, name)
	var i GetJobLockRow
	err := row.Scan(&i.Holder, &i.Touched, &i.Iteration)
	return i, err
}

const getNextReportDueTime = `-- name: GetNextReportDueTime :one
SELECT MIN(next_execution)::timestamptz
FROM report
WHERE enabled
`

func (q *Queries) GetNextReportDueTime(ctx context.Context) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getNextReportDueTime)
	var column_1 pgtype.Timestamptz
	err := row.Scan(&column_1)
	return column_1, err
}

const getReport = `-- name: GetReport :one
SELECT name, enabled, next_execution, spec
FROM report
WHERE name = $1
`

func (q *Queries) GetReport(ctx context.Context, name string) (Report, error) {
	row := q.db.QueryRow(ctx, getReport, name)
	var i Report
	err := row.Scan(
		&i.Name,
		&i.Enabled,
		&i.NextExecution,
		&i.Spec,
	)
	return i, err
}

const getSchema = `-- name: GetSchema :one
SELECT s.name, s.version, s.spec
FROM document_schema AS s
WHERE s.name = $1 AND s.version = $2
`

type GetSchemaParams struct {
	Name    string
	Version string
}

func (q *Queries) GetSchema(ctx context.Context, arg GetSchemaParams) (DocumentSchema, error) {
	row := q.db.QueryRow(ctx, getSchema, arg.Name, arg.Version)
	var i DocumentSchema
	err := row.Scan(&i.Name, &i.Version, &i.Spec)
	return i, err
}

const getSchemaVersions = `-- name: GetSchemaVersions :many
SELECT a.name, a.version
FROM active_schemas AS a
`

func (q *Queries) GetSchemaVersions(ctx context.Context) ([]ActiveSchema, error) {
	rows, err := q.db.Query(ctx, getSchemaVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActiveSchema
	for rows.Next() {
		var i ActiveSchema
		if err := rows.Scan(&i.Name, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSigningKeys = `-- name: GetSigningKeys :many
SELECT kid, spec FROM signing_keys
`

func (q *Queries) GetSigningKeys(ctx context.Context) ([]SigningKey, error) {
	rows, err := q.db.Query(ctx, getSigningKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SigningKey
	for rows.Next() {
		var i SigningKey
		if err := rows.Scan(&i.Kid, &i.Spec); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusRules = `-- name: GetStatusRules :many
SELECT name, description, access_rule, applies_to, for_types, expression
FROM status_rule
`

func (q *Queries) GetStatusRules(ctx context.Context) ([]StatusRule, error) {
	rows, err := q.db.Query(ctx, getStatusRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatusRule
	for rows.Next() {
		var i StatusRule
		if err := rows.Scan(
			&i.Name,
			&i.Description,
			&i.AccessRule,
			&i.AppliesTo,
			&i.ForTypes,
			&i.Expression,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusVersions = `-- name: GetStatusVersions :many
SELECT id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2
      AND ($3::bigint = 0 OR id < $3::bigint)
ORDER BY id DESC
LIMIT $4
`

type GetStatusVersionsParams struct {
	Uuid   uuid.UUID
	Name   string
	Before int64
	Count  int32
}

type GetStatusVersionsRow struct {
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatusVersions(ctx context.Context, arg GetStatusVersionsParams) ([]GetStatusVersionsRow, error) {
	rows, err := q.db.Query(ctx, getStatusVersions,
		arg.Uuid,
		arg.Name,
		arg.Before,
		arg.Count,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusVersionsRow
	for rows.Next() {
		var i GetStatusVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
SELECT uuid, name, id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetStatusesParams struct {
	Uuid    uuid.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

type GetStatusesRow struct {
	Uuid       uuid.UUID
	Name       string
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]GetStatusesRow, error) {
	rows, err := q.db.Query(ctx, getStatuses,
		arg.Uuid,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesRow
	for rows.Next() {
		var i GetStatusesRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersion = `-- name: GetVersion :one
SELECT created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND version = $2
`

type GetVersionParams struct {
	Uuid    uuid.UUID
	Version int64
}

type GetVersionRow struct {
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersion(ctx context.Context, arg GetVersionParams) (GetVersionRow, error) {
	row := q.db.QueryRow(ctx, getVersion, arg.Uuid, arg.Version)
	var i GetVersionRow
	err := row.Scan(
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.Archived,
	)
	return i, err
}

const getVersions = `-- name: GetVersions :many
SELECT version, created, creator_uri, meta, archived
FROM document_version
WHERE uuid = $1 AND ($2::bigint = 0 OR version < $2::bigint)
ORDER BY version DESC
LIMIT $3
`

type GetVersionsParams struct {
	Uuid   uuid.UUID
	Before int64
	Count  int32
}

type GetVersionsRow struct {
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
	Archived   bool
}

func (q *Queries) GetVersions(ctx context.Context, arg GetVersionsParams) ([]GetVersionsRow, error) {
	rows, err := q.db.Query(ctx, getVersions, arg.Uuid, arg.Before, arg.Count)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVersionsRow
	for rows.Next() {
		var i GetVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
			&i.Archived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const granteesWithPermission = `-- name: GranteesWithPermission :many
SELECT uri
FROM acl
WHERE uuid = $1
      AND $2::text = ANY(permissions)
`

type GranteesWithPermissionParams struct {
	Uuid       uuid.UUID
	Permission string
}

func (q *Queries) GranteesWithPermission(ctx context.Context, arg GranteesWithPermissionParams) ([]string, error) {
	rows, err := q.db.Query(ctx, granteesWithPermission, arg.Uuid, arg.Permission)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var uri string
		if err := rows.Scan(&uri); err != nil {
			return nil, err
		}
		items = append(items, uri)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertACLAuditEntry = `-- name: InsertACLAuditEntry :exec
INSERT INTO acl_audit(uuid, type, updated, updater_uri, state)
SELECT $1::uuid, $2, $3::timestamptz, $4::text, json_agg(l)
FROM (
       SELECT uri, permissions
       FROM acl
       WHERE uuid = $1::uuid
) AS l
`

type InsertACLAuditEntryParams struct {
	Uuid       uuid.UUID
	Type       pgtype.Text
	Updated    pgtype.Timestamptz
	UpdaterUri string
}

func (q *Queries) InsertACLAuditEntry(ctx context.Context, arg InsertACLAuditEntryParams) error {
	_, err := q.db.Exec(ctx, insertACLAuditEntry,
		arg.Uuid,
		arg.Type,
		arg.Updated,
		arg.UpdaterUri,
	)
	return err
}

const insertDeleteRecord = `-- name: InsertDeleteRecord :one
INSERT INTO delete_record(
       uuid, uri, type, version, created, creator_uri, meta
) VALUES(
       $1, $2, $3, $4, $5, $6, $7
) RETURNING id
`

type InsertDeleteRecordParams struct {
	Uuid       uuid.UUID
	Uri        string
	Type       string
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) InsertDeleteRecord(ctx context.Context, arg InsertDeleteRecordParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertDeleteRecord,
		arg.Uuid,
		arg.Uri,
		arg.Type,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertIntoEventLog = `-- name: InsertIntoEventLog :one
INSERT INTO eventlog(
       event, uuid, type, timestamp, updater, version, status, status_id, acl
) VALUES (
       $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id
`

type InsertIntoEventLogParams struct {
	Event     string
	Uuid      uuid.UUID
	Type      pgtype.Text
	Timestamp pgtype.Timestamptz
	Updater   pgtype.Text
	Version   pgtype.Int8
	Status    pgtype.Text
	StatusID  pgtype.Int8
	Acl       []byte
}

func (q *Queries) InsertIntoEventLog(ctx context.Context, arg InsertIntoEventLogParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertIntoEventLog,
		arg.Event,
		arg.Uuid,
		arg.Type,
		arg.Timestamp,
		arg.Updater,
		arg.Version,
		arg.Status,
		arg.StatusID,
		arg.Acl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertJobLock = `-- name: InsertJobLock :one
INSERT INTO job_lock(name, holder, touched, iteration)
VALUES ($1, $2, now(), 1)
RETURNING iteration
`

type InsertJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) InsertJobLock(ctx context.Context, arg InsertJobLockParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertJobLock, arg.Name, arg.Holder)
	var iteration int64
	err := row.Scan(&iteration)
	return iteration, err
}

const insertSigningKey = `-- name: InsertSigningKey :exec
INSERT INTO signing_keys(kid, spec) VALUES($1, $2)
`

type InsertSigningKeyParams struct {
	Kid  string
	Spec []byte
}

func (q *Queries) InsertSigningKey(ctx context.Context, arg InsertSigningKeyParams) error {
	_, err := q.db.Exec(ctx, insertSigningKey, arg.Kid, arg.Spec)
	return err
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const pingJobLock = `-- name: PingJobLock :execrows
UPDATE job_lock
SET touched = now(),
    iteration = iteration + 1
WHERE name = $1
      AND holder = $2
      AND iteration = $3
`

type PingJobLockParams struct {
	Name      string
	Holder    string
	Iteration int64
}

func (q *Queries) PingJobLock(ctx context.Context, arg PingJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, pingJobLock, arg.Name, arg.Holder, arg.Iteration)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const registerSchema = `-- name: RegisterSchema :exec
INSERT INTO document_schema(name, version, spec)
VALUES ($1, $2, $3)
`

type RegisterSchemaParams struct {
	Name    string
	Version string
	Spec    []byte
}

func (q *Queries) RegisterSchema(ctx context.Context, arg RegisterSchemaParams) error {
	_, err := q.db.Exec(ctx, registerSchema, arg.Name, arg.Version, arg.Spec)
	return err
}

const releaseJobLock = `-- name: ReleaseJobLock :execrows
DELETE FROM job_lock
WHERE name = $1
      AND holder = $2
`

type ReleaseJobLockParams struct {
	Name   string
	Holder string
}

func (q *Queries) ReleaseJobLock(ctx context.Context, arg ReleaseJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseJobLock, arg.Name, arg.Holder)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setDocumentStatusAsArchived = `-- name: SetDocumentStatusAsArchived :exec
UPDATE document_status
SET archived = true, signature = $1::text
WHERE uuid = $2 AND id = $3
`

type SetDocumentStatusAsArchivedParams struct {
	Signature string
	Uuid      uuid.UUID
	ID        int64
}

func (q *Queries) SetDocumentStatusAsArchived(ctx context.Context, arg SetDocumentStatusAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentStatusAsArchived, arg.Signature, arg.Uuid, arg.ID)
	return err
}

const setDocumentVersionAsArchived = `-- name: SetDocumentVersionAsArchived :exec
UPDATE document_version
SET archived = true, signature = $1::text
WHERE uuid = $2 AND version = $3
`

type SetDocumentVersionAsArchivedParams struct {
	Signature string
	Uuid      uuid.UUID
	Version   int64
}

func (q *Queries) SetDocumentVersionAsArchived(ctx context.Context, arg SetDocumentVersionAsArchivedParams) error {
	_, err := q.db.Exec(ctx, setDocumentVersionAsArchived, arg.Signature, arg.Uuid, arg.Version)
	return err
}

const setNextReportExecution = `-- name: SetNextReportExecution :exec
UPDATE report
SET next_execution = $1
WHERE name = $2
`

type SetNextReportExecutionParams struct {
	NextExecution pgtype.Timestamptz
	Name          string
}

func (q *Queries) SetNextReportExecution(ctx context.Context, arg SetNextReportExecutionParams) error {
	_, err := q.db.Exec(ctx, setNextReportExecution, arg.NextExecution, arg.Name)
	return err
}

const stealJobLock = `-- name: StealJobLock :execrows
UPDATE job_lock
SET holder = $1,
    touched = now(),
    iteration = iteration + 1
WHERE name = $2
      AND holder = $3
      AND iteration = $4
`

type StealJobLockParams struct {
	NewHolder      string
	Name           string
	PreviousHolder string
	Iteration      int64
}

func (q *Queries) StealJobLock(ctx context.Context, arg StealJobLockParams) (int64, error) {
	result, err := q.db.Exec(ctx, stealJobLock,
		arg.NewHolder,
		arg.Name,
		arg.PreviousHolder,
		arg.Iteration,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateEventsinkPosition = `-- name: UpdateEventsinkPosition :exec
UPDATE eventsink SET position = $1 WHERE name = $2
`

type UpdateEventsinkPositionParams struct {
	Position int64
	Name     string
}

func (q *Queries) UpdateEventsinkPosition(ctx context.Context, arg UpdateEventsinkPositionParams) error {
	_, err := q.db.Exec(ctx, updateEventsinkPosition, arg.Position, arg.Name)
	return err
}

const updateReport = `-- name: UpdateReport :exec
INSERT INTO report(
       name, enabled, next_execution, spec
) VALUES (
       $1, $2, $3, $4
) ON CONFLICT (name) DO UPDATE SET
  enabled = $2,
  next_execution = $3,
  spec = $4
`

type UpdateReportParams struct {
	Name          string
	Enabled       bool
	NextExecution pgtype.Timestamptz
	Spec          []byte
}

func (q *Queries) UpdateReport(ctx context.Context, arg UpdateReportParams) error {
	_, err := q.db.Exec(ctx, updateReport,
		arg.Name,
		arg.Enabled,
		arg.NextExecution,
		arg.Spec,
	)
	return err
}

const updateStatus = `-- name: UpdateStatus :exec
INSERT INTO status(name, disabled)
VALUES($1, $2)
ON CONFLICT(name) DO UPDATE SET
   disabled = $2
`

type UpdateStatusParams struct {
	Name     string
	Disabled bool
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) error {
	_, err := q.db.Exec(ctx, updateStatus, arg.Name, arg.Disabled)
	return err
}

const updateStatusRule = `-- name: UpdateStatusRule :exec
INSERT INTO status_rule(
       name, description, access_rule, applies_to, for_types, expression
) VALUES(
       $1, $2, $3, $4, $5, $6
) ON CONFLICT(name)
  DO UPDATE SET
     description = $2, access_rule = $3,
     applies_to = $4, for_types = $5, expression = $6
`

type UpdateStatusRuleParams struct {
	Name        string
	Description string
	AccessRule  bool
	AppliesTo   []string
	ForTypes    []string
	Expression  string
}

func (q *Queries) UpdateStatusRule(ctx context.Context, arg UpdateStatusRuleParams) error {
	_, err := q.db.Exec(ctx, updateStatusRule,
		arg.Name,
		arg.Description,
		arg.AccessRule,
		arg.AppliesTo,
		arg.ForTypes,
		arg.Expression,
	)
	return err
}
